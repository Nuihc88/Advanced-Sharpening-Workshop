// Advanced (Un)Sharpen Workshop - Usable Edition=ps_3_0
// Branch Codename: PhiSharpen - Pre-Alpha 1
// Code By Nuihc88
	sampler s0 :	register(s0);
	float4 p0 :		register(c0);

	#define Phi		(sqrt(1.25)+0.5)
	#define phi		(sqrt(1.25)-0.5)
	#define px		(1./p0[0])
	#define py		(1./p0[1])

// -- Settings --

		// Strength of Edge Sharpening. Also meant to take negative values for blurring, but this is broken; non-deterministic behavour; need to redo the maths.
#define EdgeSharpenFactor		pow(Phi,1)			//1.618//2.618//4.236//6.854102 Optimal range: (0.4) - (2.4) 1 - 3
		// Strength of Texture Sharpening. Also meant to take negative values for blurring, but this is broken; non-deterministic behavour; need to redo the maths.
#define TextureSharpenFactor	pow(Phi,2)			// Optimal range: (1.6) - (3.2) 2 - 6
		// Where Texture ends and Edge starts.
#define HighThreshold			pow(phi,1)			//.618//(2/3)	// Optimal range: ?
		// Where gradient protection ends and Texture starts.
#define LowThreshold			pow(phi,2)			//.382//(1/3)	// Optimal range: ?

		// Select which Edge Detection Operator to use.
#define EdgeDetector 26
		// Choose whether to use Semi-Diagonal or Regular Edge Detection Operators.
#define EdgeDetectionOperators 3 // 0=Off 1=Regular 2=SemiDiagonal 3=Both
		// Select which edge detection math to use.
#define EdgeMathMode 100

		// BarEdgeLine Prevention for incorrectly cropped material. 1-3 Least to Most aggressive, 0 disables.
#define BarEdgeLinePrevention 3
		// Select which Blur Kernel to use for Unsharp Masking.
#define BlurMaskKernel 4

		// Removes original pixel's Mask influence, it produces a light spatial smoothing effect similar to UnDot; makes things look more reflective and suppresses some mosquito noise at no performance cost. ???doublecheck???
#define MaskSmooth 1				// 0=Off, 1 = On

		// Makes sharpening strength proportional to the probability that an Edge has been detected. Reduces Sharpening Strength Factors.
#define DynamicSharpening 3 // 0=Off, 1=Texture Only, 2=Edge Only, 3=Both

		// Makes sharpening strength inversely proportional to the probability that an Edge has been detected. Inverts Dynamic Sharpening to avoid oversharpening of Textures or Edges.
#define ReciprocalDynamicS 2 // 0=Off, 1=Texture Only, 2=Edge Only, 3=Both

// -- Main Code --
//	[c23,c24,c09,c10,c11]
//	[c22,c08,c01,c02,c12]
//	[c21,c07,c00,c03,c13]
//	[c20,c06,c05,c04,c14]
//	[c19,c18,c17,c16,c15]
float4 main(float2 tex : TEXCOORD0) : COLOR {	float4 c00 = tex2D(s0, tex);
float4 c01 = tex2D(s0, tex + float2(0,-py));	float4 c02 = tex2D(s0, tex + float2(px,-py));
float4 c03 = tex2D(s0, tex + float2(px,0));		float4 c04 = tex2D(s0, tex + float2(px,py));
float4 c05 = tex2D(s0, tex + float2(0,py));		float4 c06 = tex2D(s0, tex + float2(-px,py));
float4 c07 = tex2D(s0, tex + float2(-px,0));	float4 c08 = tex2D(s0, tex + float2(-px,-py));
float4 c09 = tex2D(s0, tex + float2(0,-py*2));	float4 c10 = tex2D(s0, tex + float2( px,-py*2));
float4 c11 = tex2D(s0, tex + float2(px,-py)*2);	float4 c12 = tex2D(s0, tex + float2( px*2,-py));
float4 c13 = tex2D(s0, tex + float2(px*2,0));	float4 c14 = tex2D(s0, tex + float2( px*2,py));
float4 c15 = tex2D(s0, tex + float2(px,py)*2);	float4 c16 = tex2D(s0, tex + float2(-px,py*2));
float4 c17 = tex2D(s0, tex + float2(0,py*2));	float4 c18 = tex2D(s0, tex + float2(-px,py*2));
float4 c19 = tex2D(s0, tex + float2(-px,py)*2);	float4 c20 = tex2D(s0, tex + float2(-px*2,py));
float4 c21 = tex2D(s0, tex + float2(-px*2,0));	float4 c22 = tex2D(s0, tex + float2(-px*2,-py));
float4 c23 = tex2D(s0, tex + float2(-px,-py)*2);float4 c24 = tex2D(s0, tex + float2(-px,-py*2));

// -- Blur Mask Kernel --

#if BlurMaskKernel == 0 // 5x5 Gradient Kernel - Very Smooth and reflective. Based on an earlier 8(+1) texture fetch approach inspired by LumaSharpen, but which was abandoned as it would have little to no performance benefit when used together with Edge Detection and/or Plain Detection...
int3 BlurTiers[2] = { 1, 2, 3, 4, 6, 9 };			//	[1 , 2 , 3 , 2 , 1]	//	[1/9,2/9,1/3,2/9,1/9]
float4	Mask  = BlurTiers[1][1]*(c01+c03+c05+c07);	//	[2 , 4 , 6 , 4 , 2]	//	[2/9,4/9,2/3,4/9,2/9]
		Mask += BlurTiers[1][0]*(c02+c04+c06+c08);	//	[3 , 6 , 9 , 6 , 3]	//	[1/3,2/3, 1 ,2/3,1/3]
		Mask += BlurTiers[0][2]*(c09+c13+c17+c21);	//	[2 , 4 , 6 , 4 , 2]	//	[2/9,4/9,2/3,4/9,2/9]
		Mask += BlurTiers[0][0]*(c11+c15+c19+c23);	//	[1 , 2 , 3 , 2 , 1]	//	[1/9,2/9,1/3,2/9,1/9]
		Mask += BlurTiers[0][1]*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 0 && MaskSmooth == 1
	Mask  /= 72;
#elif BlurMaskKernel == 0 && MaskSmooth == 0
	Mask += BlurTiers[1][2]*c00;	Mask  /= 81;
#endif

#if BlurMaskKernel == 1 // 5x5 Fibonacci Kernel - An approcimation of the Golden Ratio, gives excellent balance between smoothness and sharpness.
int3 BlurTiers[2] = { 1, 2, 3, 5, 8, 13 };			//	[1 , 2 , 3 , 2 , 1]
float4	Mask  = BlurTiers[1][1]*(c01+c03+c05+c07);	//	[2 , 5 , 8 , 5 , 2]
		Mask += BlurTiers[1][0]*(c02+c04+c06+c08);	//	[3 , 8 ,13 , 8 , 3]
		Mask += BlurTiers[0][2]*(c09+c13+c17+c21);	//	[2 , 5 , 8 , 5 , 2]
		Mask += BlurTiers[0][0]*(c11+c15+c19+c23);	//	[1 , 2 , 3 , 2 , 1]
		Mask += BlurTiers[0][1]*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 1 && MaskSmooth == 1
	Mask  /= 84;
#elif BlurMaskKernel == 1 && MaskSmooth == 0
	Mask += BlurTiers[1][2]*c00; Mask  /= 97;
#endif




#if BlurMaskKernel == 2 // 5x5 Test - An experiment to reduce the instruction count; seems to work, but is performance affected? Requires further testing.
int3 BlurTiers[2] = { 1, 2, 3, 5, 8, 13 }; 			// 	[1 , 2 , 3 , 2 , 1]
float4	Mask  = BlurTiers[1][1]*(c01+c03+c05+c07);	//	[2 , 5 , 8 , 5 , 2]
		Mask += BlurTiers[1][0]*(c02+c04+c06+c08);	//	[3 , 8 ,13 , 8 , 3]
		Mask += BlurTiers[0][2]*(c09+c13+c17+c21);	//	[2 , 5 , 8 , 5 , 2]
		Mask += BlurTiers[0][0]*(c11+c15+c19+c23);	//	[1 , 2 , 3 , 2 , 1]
		Mask += BlurTiers[0][1]*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 2 && MaskSmooth == 1
	Mask  /= 84;
#elif BlurMaskKernel == 2 && MaskSmooth == 0
	Mask += BlurTiers[1][2]*c00;	Mask  /= 97;
#endif

#if BlurMaskKernel == 3 // 5x5 Powers of Phi - An experiment to reduce the instruction count and further increase precision...
												// 	[^1 ,^2 ,^3 ,^2 ,^1]
float4	Mask  = pow(Phi,5)*(c01+c03+c05+c07);	//	[^2 ,^4 ,^5 ,^4 ,^2]
		Mask += pow(Phi,4)*(c02+c04+c06+c08);	//	[^3 ,^5 ,^6 ,^5 ,^3]
		Mask += pow(Phi,3)*(c09+c13+c17+c21);	//	[^2 ,^4 ,^5 ,^4 ,^2]
		Mask += pow(Phi,1)*(c11+c15+c19+c23);	//	[^1 ,^2 ,^3 ,^2 ,^1]
		Mask += pow(Phi,2)*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 3 && MaskSmooth == 1
	Mask /= 116,138;							// ((sqrt(1,25)+0,5)^5*4) + ((sqrt(1,25)+0,5)^4*4) + ((sqrt(1,25)+0,5)^3*4) + ((sqrt(1,25)+0,5)^1*4) + ((sqrt(1,25)+0,5)^2*8)
#elif BlurMaskKernel == 3 && MaskSmooth == 0
	Mask += pow(Phi,6)*c00;	Mask  /= 134,082; 	// ((sqrt(1,25)+0,5)^5*4) + ((sqrt(1,25)+0,5)^4*4) + ((sqrt(1,25)+0,5)^3*4) + ((sqrt(1,25)+0,5)^1*4) + ((sqrt(1,25)+0,5)^2*8) + ((sqrt(1,25)+0,5)^6*1)
#endif

#if BlurMaskKernel == 4 // 5x5 Powers of phi - An experiment to reduce the instruction count and further increase precision...
												// 	[^6 ,^5 ,^4 ,^5 ,^6]
float4	Mask  = pow(phi,2)*(c01+c03+c05+c07);	//	[^5 ,^3 ,^2 ,^3 ,^5]
		Mask += pow(phi,3)*(c02+c04+c06+c08);	//	[^4 ,^2  ,1 ,^2 ,^4]
		Mask += pow(phi,4)*(c09+c13+c17+c21);	//	[^5 ,^3 ,^2 ,^3 ,^5]
		Mask += pow(phi,6)*(c11+c15+c19+c23);	//	[^6 ,^5 ,^4 ,^5 ,^6]
		Mask += pow(phi,5)*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 4 && MaskSmooth == 1
	Mask /=  4;									// ((sqrt(1,25)-0,5)^2*4) + ((sqrt(1,25)-0,5)^3*4) + ((sqrt(1,25)-0,5)^4*4) + ((sqrt(1,25)-0,5)^6*4) + ((sqrt(1,25)-0,5)^5*8)
#elif BlurMaskKernel == 4 && MaskSmooth == 0
	Mask += phi*c00;	Mask	/= 4+phi; 		// ((sqrt(1,25)-0,5)^2*4) + ((sqrt(1,25)-0,5)^3*4) + ((sqrt(1,25)-0,5)^4*4) + ((sqrt(1,25)-0,5)^6*4) + ((sqrt(1,25)-0,5)^5*8) + ((sqrt(1,25)-0,5)^1*1)
#endif

// -- Edge Detection Operator --

#if EdgeDetector == 2 // Scharr-Operators -  Excellent for Anime, CGI & Live content alike.
// [ -3,-10,-3 ]	[  3,  0, -3 ]	[  0,  3, 10 ]	[-10, -3,  0 ]
// [  0,  0, 0 ]	[ 10,  0,-10 ]	[ -3,  0,  3 ]	[ -3,  0,  3 ]
// [  3, 10, 3 ]	[  3,  0, -3 ]	[-10, -3,  0 ]	[  0,  3, 10 ]
// Semi-Diagonals // Meant to reduce amplification of aliasing and interlacing artefacts over regular operators, slightly softer results on average.
// [ -3,-10,-10 ]	[ 10,  3, -3 ]	[ -3,  3, 10]	[-10,-10, -3 ]
// [  3,  0, -3 ]	[ 10,  0,-10 ]	[-10,  0, 10 ]	[ -3,  0,  3 ]
// [ 10, 10,  3 ]	[  3, -3,-10 ]	[-10, -3,  3 ]	[  3, 10, 10 ]
float4 EdgeTierData = { 3, 10, 0.16, 0.26 };
#endif

#if EdgeDetector == 21 // Low-Precision GoldenRatio-Operators -   After i realized that 10:(3*2) of Scharr is pretty close to the golden ratio, i started trying out other approximations of it, these give very pleasing results.
// Experimental ( 1.625:1 ) approcimation of Phi; where the smaller value is divided across two pixels.
// [ -4,-13,-4 ]	[  4,  0, -4 ]	[  0,  4, 13 ]	[-13, -4,  0 ]
// [  0,  0, 0 ]	[ 13,  0,-13 ]	[ -4,  0,  4 ]	[ -4,  0,  4 ]
// [  4, 13, 4 ]	[  4,  0, -4 ]	[-13, -4,  0 ]	[  0,  4, 13 ]
// Semi-Diagonals // Meant to reduce amplification of aliasing and interlacing artefacts over regular operators, slightly softer results on average.
// [ -4,-13,-13 ]	[ 13,  4, -4 ]	[ -4,  4, 13 ]	[-13,-13, -4 ]
// [  4,  0, -4 ]	[ 13,  0,-13 ]	[-13,  0, 13 ]	[ -4,  0,  4 ]
// [ 13, 13,  4 ]	[  4, -4,-13 ]	[-13, -4,  4 ]	[  4, 13, 13 ]
float4 EdgeTierData = { 4, 13, 0.21, 0.34 };
#endif

#if EdgeDetector == 22 // Medium-Precision GoldenRatio-Operators -   
// Experimental ( 1.61805[...]:1 ) approcimation of Phi; where the smaller value is divided across two pixels.
// [ -72,-233, -72 ]	[  72,  0, -72 ]	[   0, 72, 233 ]	[-233, -72,   0 ]
// [   0,   0,   0 ]	[ 233,  0,-233 ]	[ -72,  0,  72 ]	[ -72,   0,  72 ]
// [  72, 233,  72 ]	[  72,  0, -72 ]	[-233,-72,   0 ]	[   0,  72, 233 ]
// Semi-Diagonals // Meant to reduce amplification of aliasing and interlacing artefacts over regular operators, slightly softer results on average.
// [ -72,-233,-233 ]	[ 233, 72, -72 ]	[ -72, 72, 233 ]	[-233,-233, -72 ]
// [  72,   0, -72 ]	[ 233,  0,-233 ]	[-233,  0, 233 ]	[ -72,   0,  72 ]
// [ 233, 233,  72 ]	[  72,-72,-233 ]	[-233,-72,  72 ]	[  72, 233, 233 ]
float4 EdgeTierData = { 72, 233, 3.77, 6.10 };
#endif

#if EdgeDetector == 23 // Medium-Precision GoldenRatio-Operators -   
// Experimental ( 1.61805[...]:1 ) approcimation of Phi; where both values are divided across two pixels.
float4 EdgeTierData = { 72, 116.5, 2.605, 3.77 };
#endif

#if EdgeDetector == 233 // Medium-Precision GoldenRatio-Operators -   
// Experimental ( 1.61805[...]:1 ) approcimation of Phi; where both values are divided across two pixels.
float4 EdgeTierData = { 144, 233, 5.21, 7.54 };
#endif

#if EdgeDetector == 24 // Medium-Precision GoldenRatio-Operators -   
// Experimental ( 1.61805[...]:1 ) approcimation of Phi; hybrid combo with different behavior for regular and semi-diagonal operators.
float4 EdgeTierData = { 72, 233, 3.77, 5.21 };
#endif
// Special exception for Experimentation purposes. Will eventually get either moved or deleted depending on the results.
#if SemiDiagonalOperators == 1  && EdgeDetector == 24
EdgeTierData[0] *= 2;
#endif

#if EdgeDetector == 25 // Experimental; Phi, cut off before zeros and rounded up at convenient clusters of high digits;
// even more precision should be achievable just by adding more digits, but at some point the performance trade-off just isn't worth it; not quite sure how to test that, so i'll just leave this here as an option for anyone who likes to experiment and run benchmarks.
#define prePhi 1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374
float4 EdgeTierData = { .5, prePhi, (1+prePhi/100), (1+prePhi*2/100) };
// Phi rounded, up to 101 digits after the decimal point:
//1.618
//1.61803398875
//1.618033988749895
//1.6180339887498948482
//1.61803398874989484820458683436563811772
//1.6180339887498948482045868343656381177203
//1.61803398874989484820458683436563811772030918
//1.6180339887498948482045868343656381177203091798
//1.6180339887498948482045868343656381177203091798057628621354486227
//1.61803398874989484820458683436563811772030917980576286213544862270526
//1.61803398874989484820458683436563811772030917980576286213544862270526046282
//1.6180339887498948482045868343656381177203091798057628621354486227052604628189
//1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497
//1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072
//1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072
//1.61803398874989484820458683436563811772030917980576286213544862270526046281890244970720720419
//1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375
#endif

#if EdgeDetector == 26 // Should automatically calculate Phi to maximum available precision while loading shader.
float4 EdgeTierData = { .5, Phi, (1+Phi/100), (1+Phi*2/100) }; // Latter values are for calibrating Sharpening-strength normalization across EdgeDetector modes.
#endif

float4 Edge1 = {0,0,0,0}; float4 Edge2 = {0,0,0,0}; float4 Edge3 = {0,0,0,0}; float4 Edge4 = {0,0,0,0}; float4 Edge5 = {0,0,0,0}; float4 Edge6 = {0,0,0,0}; float4 Edge7 = {0,0,0,0}; float4 Edge8 = {0,0,0,0}; 

#if EdgeDetectionOperators == 1 || EdgeDetectionOperators == 3
#endif
#if EdgeDetectionOperators == 2 || EdgeDetectionOperators == 3
#endif

// -- Do The Maths --


#if   EdgeMathMode == 0	// My Best experimental approach this far:
//float   DetectEdges = saturate( max( max( max(Edge1,Edge2) , max(Edge3,Edge4) ) , max( max(Edge5,Edge6) , max(Edge7,Edge8) )));

#elif   EdgeMathMode == 10	// My Best experimental approach this far:
float3  Edges ={ max(Edge1,Edge2) , max(Edge3,Edge4) ) , max( max(Edge5,Edge6) , max(Edge7,Edge8) )};
float  DetectEdges =saturate( max( max(Edges[0]),(Edges[1]) ) , Edges[2] );

#elif   EdgeMathMode == 100	// My Best experimental approach this far:

float4x4 Edges[2]={abs((c05*EdgeTierData[1]+(c04+c06)*EdgeTierData[0])-(c01*EdgeTierData[1]+(c08+c02)*EdgeTierData[0]))/EdgeTierData[2] ,
				abs((c07*EdgeTierData[1]+(c06+c08)*EdgeTierData[0])-(c03*EdgeTierData[1]+(c02+c04)*EdgeTierData[0]))/EdgeTierData[2] ,
				abs((c02*EdgeTierData[1]+(c01+c03)*EdgeTierData[0])-(c06*EdgeTierData[1]+(c05+c07)*EdgeTierData[0]))/EdgeTierData[2] ,
				abs((c04*EdgeTierData[1]+(c03+c05)*EdgeTierData[0])-(c08*EdgeTierData[1]+(c07+c01)*EdgeTierData[0]))/EdgeTierData[2] ,
				abs(((c05+c06)*EdgeTierData[1]+(c04+c07)*EdgeTierData[0])-((c01+c02)*EdgeTierData[1]+(c08+c03)*EdgeTierData[0]))/EdgeTierData[3] ,
				abs(((c07+c08)*EdgeTierData[1]+(c06+c01)*EdgeTierData[0])-((c03+c04)*EdgeTierData[1]+(c02+c05)*EdgeTierData[0]))/EdgeTierData[3] ,
				abs(((c02+c03)*EdgeTierData[1]+(c01+c04)*EdgeTierData[0])-((c06+c07)*EdgeTierData[1]+(c05+c08)*EdgeTierData[0]))/EdgeTierData[3] ,
				abs(((c04+c05)*EdgeTierData[1]+(c03+c06)*EdgeTierData[0])-((c08+c01)*EdgeTierData[1]+(c07+c02)*EdgeTierData[0]))/EdgeTierData[3] };


float4  DetectEdges ={saturate( max(
max( max( Edges[0][0],Edges[0][1] ) , max( Edges[0][2],Edges[0][3] ) )
, 
max( max( Edges[1][0],Edges[1][1] ) , max( Edges[1][2],Edges[1][3] ) )
 ))};


#elif EdgeMathMode == 1	// Kirsch-like max approach:

float	DetectRegularEdges = max(max(Edge1,Edge2),max(Edge3,Edge4));
float	DetectSemiDiagonalEdges = max(max(Edge5,Edge6),max(Edge7,Edge8));
float4   DetectEdges = {saturate(max(DetectEdges[0]) )};

#elif EdgeMathMode == 2	// placeholder for theoretically sound approaches:
float	DetectEdges = saturate(sqrt(dot( dot( abs(Edge1),abs(Edge2) ),dot( abs(Edge3),abs(Edge4) ) )));// with or without abs?

#elif EdgeMathMode == 3	// Recommended approach:
float	DetectEdges = saturate(dot( dot( abs(Edge1),abs(Edge2) ),dot( abs(Edge3),abs(Edge4) ) )/4);

#elif EdgeMathMode == 4	// SharpenComplex aproach:
float	DetectEdges = saturate(sqrt(mul(Edge1,Edge1)+mul(Edge2,Edge2)+mul(Edge3,Edge3)+mul(Edge4,Edge4)));

#elif EdgeMathMode == 5	// Min aproach:
float	DetectEdges = saturate(min(min(abs(Edge1),abs(Edge2)),min(abs(Edge3),abs(Edge4))));

#else 					// Experimental/Diagnostic aproaches:
//float	DetectEdges = saturate(dot(dot(abs(Edge1),abs(Edge2)),dot(abs(Edge3),abs(Edge4))));
//float	DetectEdges = saturate((abs(Edge1)+abs(Edge2)+abs(Edge3)+abs(Edge4))/4);
//float	DetectEdges = sqrt(Edge1+Edge2+Edge3+Edge4/4);
//float	DetectEdges = abs(Edge1+Edge2+Edge3+Edge4)/4;
//float	DetectEdges = sqrt(dot(Edge1,Edge2)+dot(Edge3,Edge4))/4;
//float	DetectEdges = abs(dot(Edge1,Edge2)+dot(Edge3,Edge4))/4;
//float	DetectEdges = saturate((Edge1+Edge2+Edge3+Edge4)/4);
//float	DetectEdges = abs(dot(abs(Edge1),abs(Edge2))+dot(abs(Edge3),abs(Edge4)))/4;
float	DetectEdges = dot(dot( abs(Edge1),abs(Edge2) ),dot( abs(Edge3),abs(Edge4) ))/4;
//float	DetectEdges = saturate(sqrt(dot( dot(Edge1,Edge2),dot(Edge3,Edge4) ))/4);
//float	DetectEdges = saturate(sqrt( mul(Edge1,Edge2)+mul(Edge3,Edge4) ));
#endif

//EdgeStrength Average
//float	EdgeStrength = (DetectEdges.r+DetectEdges.b+DetectEdges.g)/3;
//EdgeStrength Color Max
float	EdgeStrength = max(max(DetectEdges.r,DetectEdges.b),DetectEdges.g);
float4 EdgeSharpeningMath;
#if DynamicSharpening == 2 && ReciprocalDynamicS == 0 || DynamicSharpening == 3 && ReciprocalDynamicS == 0 || DynamicSharpening == 2 && ReciprocalDynamicS == 1 || DynamicSharpening == 3 && ReciprocalDynamicS == 1
EdgeSharpeningMath.rgb = c00-(Mask-c00)*EdgeStrength*EdgeSharpenFactor;
#elif DynamicSharpening == 2 && ReciprocalDynamicS == 2 || DynamicSharpening == 3 && ReciprocalDynamicS == 2 || DynamicSharpening == 2 && ReciprocalDynamicS == 3 || DynamicSharpening == 3 && ReciprocalDynamicS == 3
EdgeSharpeningMath.rgb = c00-(Mask-c00)*(1/EdgeStrength)*EdgeSharpenFactor;
#else
EdgeSharpeningMath.rgb = c00-(Mask-c00)*EdgeSharpenFactor;
#endif

float4 TextureSharpeningMath;
#if DynamicSharpening == 1 && ReciprocalDynamicS == 0 || DynamicSharpening == 3 && ReciprocalDynamicS == 0 || DynamicSharpening == 1 && ReciprocalDynamicS == 2 || DynamicSharpening == 3 && ReciprocalDynamicS == 2
TextureSharpeningMath.rgb = c00-(Mask-c00)*EdgeStrength*TextureSharpenFactor;
#elif DynamicSharpening == 1 && ReciprocalDynamicS == 1 || DynamicSharpening == 3 && ReciprocalDynamicS == 1 || DynamicSharpening == 1 && ReciprocalDynamicS == 3 || DynamicSharpening == 3 && ReciprocalDynamicS == 3
TextureSharpeningMath.rgb = c00-(Mask-c00)*(1/EdgeStrength)*TextureSharpenFactor;
#else
TextureSharpeningMath.rgb = c00-(Mask-c00)*TextureSharpenFactor;
#endif

	 if (EdgeStrength>HighThreshold)
		{EdgeSharpeningMath.a = 1; return EdgeSharpeningMath;}
else if (EdgeStrength>LowThreshold)
		{TextureSharpeningMath.a = 1; return TextureSharpeningMath;}
	 else{c00.a = 1; return c00;}
}