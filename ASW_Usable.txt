// Advanced (Un)Sharpen Workshop - Usable Edition=ps_3_0
// Branch Codename: PhiSharpen - Pre-Alpha 1
// Code By Nuihc88
	sampler s0 :	register(s0);
	float4 p0 :		register(c0);

	#define Phi		(sqrt(1.25)+.5)	// (1+(sqrt(5))/2) //((sqrt(5)+1)*.5)
	#define phi		(sqrt(1.25)-.5)	// (1-(sqrt(5))/2) //((sqrt(5)-1)*.5)

	#define px		(1./p0[0])
	#define py		(1./p0[1])

// -- Settings --

		// Strength of Edge Sharpening. Also meant to take negative values for blurring, but this is broken; non-deterministic behavour; need to redo the maths.
#define EdgeSharpenFactor		pow(Phi,1)			//1.618//2.618//4.236//6.854102 Optimal range: (0.4) - (2.4) 1 - 3
		// Strength of Texture Sharpening. Also meant to take negative values for blurring, but this is broken; non-deterministic behavour; need to redo the maths.
#define TextureSharpenFactor	pow(Phi,3)			// Optimal range: (1.6) - (3.2) 2 - 6
		// Where Texture ends and Edge starts.
#define HighThreshold			pow(phi,1)			//.618//(2/3)	// Optimal range: ?
		// Where gradient protection ends and Texture starts.
#define LowThreshold			pow(phi,4)			//.382//(1/3)	// Optimal range: ?

		// Select which Edge Detection Operator to use.
#define EdgeDetector 26
		// Choose whether to use Semi-Diagonal or Regular Edge Detection Operators.
#define EdgeDetectionOperators 5 // 0=Off 1=Regular 2=SemiDiagonal 3=Both
		// Select which edge detection math to use.
#define EdgeMathMode 0

		// BarEdgeLine Prevention for incorrectly cropped material. 1-3 Least to Most aggressive, 0 disables.
#define BarEdgeLinePrevention 3
// If edge is detected, recalculate EdgeStrength
		// Select which Blur Kernel to use for Unsharp Masking.
#define BlurMaskKernel 4

		// Removes original pixel's Mask influence, it produces a light spatial smoothing effect similar to UnDot; makes things look more reflective and suppresses some mosquito noise at no performance cost. ???doublecheck???
#define MaskSmooth 1				// 0=Off, 1 = On

		// Makes sharpening strength proportional to the probability that an Edge has been detected. Reduces Sharpening Strength Factors.
#define DynamicSharpening 3 // 0=Off, 1=Texture Only, 2=Edge Only, 3=Both

		// Makes sharpening strength inversely proportional to the probability that an Edge has been detected. Inverts Dynamic Sharpening to avoid oversharpening of Textures or Edges.
#define ReciprocalDynamicS 2 // 0=Off, 1=Texture Only, 2=Edge Only, 3=Both

#define AntiHaloMode 3 // 0=Off, 1=Texture Only, 2=Edge Only, 3=Both

//#define test 1

// -- Main Code --
//	[c23,c24,c09,c10,c11]
//	[c22,c08,c01,c02,c12]
//	[c21,c07,c00,c03,c13]
//	[c20,c06,c05,c04,c14]
//	[c19,c18,c17,c16,c15]
// -- Main Code --
//	[c46,c47,c48,c25,c26,c27,c28] c25 c31 c37 c43
//	[c45,c23,c24,c09,c10,c11,c29] c26 c30 c32 c36 c38 c42 c44 c48
//	[c44,c22,c08,c01,c02,c12,c30] c27 c29 c33 c35 c39 c41 c45 c47
//	[c43,c21,c07,c00,c03,c13,c31] c28 c34 c40 c46
//	[c42,c20,c06,c05,c04,c14,c32]
//	[c41,c19,c18,c17,c16,c15,c33]
//	[c40,c39,c38,c37,c36,c35,c34]
float4 main(float2 tex : TEXCOORD0) : COLOR {	float4 c00 = tex2D(s0, tex);
float4 c01 = tex2D(s0, tex + float2(0,-py));	float4 c02 = tex2D(s0, tex + float2(px,-py));
float4 c03 = tex2D(s0, tex + float2(px,0));		float4 c04 = tex2D(s0, tex + float2(px,py));
float4 c05 = tex2D(s0, tex + float2(0,py));		float4 c06 = tex2D(s0, tex + float2(-px,py));
float4 c07 = tex2D(s0, tex + float2(-px,0));	float4 c08 = tex2D(s0, tex + float2(-px,-py));
float4 c09 = tex2D(s0, tex + float2(0,-py*2));	float4 c10 = tex2D(s0, tex + float2( px,-py*2));
float4 c11 = tex2D(s0, tex + float2(px,-py)*2);	float4 c12 = tex2D(s0, tex + float2( px*2,-py));
float4 c13 = tex2D(s0, tex + float2(px*2,0));	float4 c14 = tex2D(s0, tex + float2( px*2,py));
float4 c15 = tex2D(s0, tex + float2(px,py)*2);	float4 c16 = tex2D(s0, tex + float2(-px,py*2));
float4 c17 = tex2D(s0, tex + float2(0,py*2));	float4 c18 = tex2D(s0, tex + float2(-px,py*2));
float4 c19 = tex2D(s0, tex + float2(-px,py)*2);	float4 c20 = tex2D(s0, tex + float2(-px*2,py));
float4 c21 = tex2D(s0, tex + float2(-px*2,0));	float4 c22 = tex2D(s0, tex + float2(-px*2,-py));
float4 c23 = tex2D(s0, tex + float2(-px,-py)*2);float4 c24 = tex2D(s0, tex + float2(-px,-py*2));

float4 c25 = tex2D(s0, tex + float2(0,-py*3));		float4 c26 = tex2D(s0, tex + float2(px,-py*3));
float4 c27 = tex2D(s0, tex + float2(px*2,-py*3));	float4 c28 = tex2D(s0, tex + float2(px,-py)*3);
float4 c29 = tex2D(s0, tex + float2(px*3,-py*2));	float4 c30 = tex2D(s0, tex + float2(px*3,-py));
float4 c31 = tex2D(s0, tex + float2(px*3,0));		float4 c32 = tex2D(s0, tex + float2(px*3,py));
float4 c33 = tex2D(s0, tex + float2(px*3,py*2));	float4 c34 = tex2D(s0, tex + float2(px,py)*3);
float4 c35 = tex2D(s0, tex + float2(px*2,py*3));	float4 c36 = tex2D(s0, tex + float2(px,py*3));
float4 c37 = tex2D(s0, tex + float2(0,py*3));		float4 c38 = tex2D(s0, tex + float2(-px,py*3));
float4 c39 = tex2D(s0, tex + float2(-px*2,py*3));	float4 c40 = tex2D(s0, tex + float2(-px,py)*3);
float4 c41 = tex2D(s0, tex + float2(-px*3,py*2));	float4 c42 = tex2D(s0, tex + float2(-px*3,py));
float4 c43 = tex2D(s0, tex + float2(-px*3,0));		float4 c44 = tex2D(s0, tex + float2(-px*3,-py));
float4 c45 = tex2D(s0, tex + float2(-px*3,-py*2));	float4 c46 = tex2D(s0, tex + float2(-px,-py)*3);
float4 c47 = tex2D(s0, tex + float2(-px*2,-py*3));	float4 c48 = tex2D(s0, tex + float2(-px,-py*3));


#if test == 1 //texture fetches arranged by distance. For cleaner looking code.


		// 	[^9 ,^8 ,^7 ,^6 ,^7 ,^8 ,^9]
		//	[^8 ,^6 ,^5 ,^4 ,^5 ,^6 ,^8]
		//	[^7 ,^5  ,3 ,^2 ,^3 ,^5 ,^7]
		//	[^6 ,^4 ,^2 ,^1 ,^2 ,^4 ,^6]
		//	[^7 ,^5 ,^3 ,^2 ,^3 ,^5 ,^7]
		//	[^8 ,^6 ,^5 ,^4 ,^5 ,^6 ,^8]
		//	[^9 ,^8 ,^7 ,^6 ,^7 ,^8 ,^9]


 float4 CenterPixel = tex2D(s0, tex);
		Mask = phi*CenterPixel;
float4x4 sampleNeighbor[2]=
{tex2D(s0, tex + float2(0,-py))		,	tex2D(s0, tex + float2(px,0))		,	tex2D(s0, tex + float2(0,py))		,	tex2D(s0, tex + float2(-px,0))		,
 tex2D(s0, tex + float2(px,-py))	,	tex2D(s0, tex + float2(px,py))		,	tex2D(s0, tex + float2(-px,py))		,	tex2D(s0, tex + float2(-px,-py))}	;
		Mask += pow(phi,2)*(sF[0][0],sF[0][1],sF[0][2],sF[0][3]);//
		Mask += pow(phi,3)*(sF[1][0],sF[1][1],sF[1][2],sF[1][3]);//
float4x4 sampleNear[4]=
{tex2D(s0, tex + float2(0,-py*2))	,	tex2D(s0, tex + float2(px*2,0))		,	tex2D(s0, tex + float2(0,py*2))		,	tex2D(s0, tex + float2(-px*2,0))	,
 tex2D(s0, tex + float2( px,-py*2))	,	tex2D(s0, tex + float2( px*2,py))	,	tex2D(s0, tex + float2(-px,py*2))	,	tex2D(s0, tex + float2(-px*2,-py))	,
 tex2D(s0, tex + float2( px*2,-py))	,	tex2D(s0, tex + float2(-px,py*2))	,	tex2D(s0, tex + float2(-px*2,py))	,	tex2D(s0, tex + float2(-px,-py*2))	,
 tex2D(s0, tex + float2(px,-py)*2)	,	tex2D(s0, tex + float2(px,py)*2)	,	tex2D(s0, tex + float2(-px,py)*2)	,	tex2D(s0, tex + float2(-px,-py)*2)}	;
		Mask += pow(phi,4)*(sF[0][0],sF[0][1],sF[0][2],sF[0][3]);//
		Mask += pow(phi,5)*(sF[1][0],sF[1][1],sF[1][2],sF[1][3]);//
		Mask += pow(phi,5)*(sF[2][0],sF[2][1],sF[2][2],sF[2][3]);//
		Mask += pow(phi,6)*(sF[3][0],sF[3][1],sF[3][2],sF[3][3]);//
float4x4 sampleFar[6]=
{tex2D(s0, tex + float2(0,-py*3))	,	tex2D(s0, tex + float2(px*3,0))		,	tex2D(s0, tex + float2(0,py*3))		,	tex2D(s0, tex + float2(-px*3,0))	,
 tex2D(s0, tex + float2(px,-py*3))	,	tex2D(s0, tex + float2(px*3,-py))	,	tex2D(s0, tex + float2(px*3,py))	,	tex2D(s0, tex + float2(px,py*3))	,
 tex2D(s0, tex + float2(-px,py*3))	,	tex2D(s0, tex + float2(-px*3,py))	,	tex2D(s0, tex + float2(-px*3,-py))	,	tex2D(s0, tex + float2(-px,-py*3))	,
 tex2D(s0, tex + float2(px*2,-py*3)),	tex2D(s0, tex + float2(px*3,-py*2))	,	tex2D(s0, tex + float2(px*3,py*2))	,	tex2D(s0, tex + float2(px*2,py*3))	,
 tex2D(s0, tex + float2(-px*2,py*3)),	tex2D(s0, tex + float2(-px*3,py*2))	,	tex2D(s0, tex + float2(-px*3,-py*2)),	tex2D(s0, tex + float2(-px*2,-py*3)),
 tex2D(s0, tex + float2(px,-py)*3)	,	tex2D(s0, tex + float2(px,py)*3)	,	tex2D(s0, tex + float2(-px,py)*3)	,	tex2D(s0, tex + float2(-px,-py)*3)}	;
		Mask += pow(phi,6)*(sF[0][0],sF[0][1],sF[0][2],sF[0][3]);//
		Mask += pow(phi,7)*(sF[1][0],sF[1][1],sF[1][2],sF[1][3]);//
		Mask += pow(phi,7)*(sF[2][0],sF[2][1],sF[2][2],sF[2][3]);//
		Mask += pow(phi,8)*(sF[3][0],sF[3][1],sF[3][2],sF[3][3]);//
		Mask += pow(phi,8)*(sF[4][0],sF[4][1],sF[4][2],sF[4][3]);//
		Mask += pow(phi,9)*(sF[5][0],sF[5][1],sF[5][2],sF[5][3]);//
#endif

// -- Main Code --
//	[c46,c47,c48,c25,c26,c27,c28] c25 c31 c37 c43
//	[c45,c23,c24,c09,c10,c11,c29] c26 c30 c32 c36 c38 c42 c44 c48
//	[c44,c22,c08,c01,c02,c12,c30] c27 c29 c33 c35 c39 c41 c45 c47
//	[c43,c21,c07,c00,c03,c13,c31] c28 c34 c40 c46
//	[c42,c20,c06,c05,c04,c14,c32]
//	[c41,c19,c18,c17,c16,c15,c33]
//	[c40,c39,c38,c37,c36,c35,c34]



// Anti-Halo Filter //
#if AntiHaloMode > 0

float4 RangeMin  = 0;				// Placeholder declaration...
	   //RangeMin -= RangeMin-c00;	// Center Pixel, softens lines...
	   //Neigbor
RangeMin -= RangeMin-min(RangeMin,min( min(c01,c05),min(c03,c07) ) );
RangeMin -= RangeMin-min(RangeMin,min( min(c02,c07),min(c04,c08) ) );
       //Near
RangeMin -= RangeMin-min(RangeMin,min( min(c09,c17),min(c13,c21) ) );
RangeMin -= RangeMin-min(RangeMin,min(min(min(c10,c18),min(c12,c20)),min(min(c14,c22),min(c16,c24)))); //Denitely Keep
       RangeMin -= RangeMin-min(RangeMin,min( min(c11,c19),min(c15,c23) ) );
       //Far
//RangeMin -= RangeMin-min(RangeMin,min( min(c25,c37),min(c31,c43) ) );
//       RangeMin -= RangeMin-min(RangeMin,min(min(min(c26,c30),min(c32,c36)),min(min(c38,c42),min(c44,c48))));
//	   RangeMin -= RangeMin-min(RangeMin,min(min(min(c27,c29),min(c33,c35)),min(min(c39,c41),min(c45,c47))));
//RangeMin -= RangeMin-min(RangeMin,min( min(c28,c34),min(c40,c46) ) );


float4 RangeMax  = 0;				// Placeholder declaration...
	 //RangeMax  -= RangeMax-c00;	// Center Pixel, softens lines...
     //Neigbor
RangeMax -= RangeMax-max(RangeMax,max( max(c01,c05),max(c03,c07) ) );
RangeMax -= RangeMax-max(RangeMax,max( max(c02,c07),max(c04,c08) ) );
     //Near
RangeMax -= RangeMax-max(RangeMax,max( max(c09,c17),max(c13,c21) ) );
RangeMax -= RangeMax-max(RangeMax,max(max(max(c10,c18),max(c12,c20)),max(max(c14,c22),max(c16,c24)))); //Denitely Keep
       RangeMax -= RangeMax-max(RangeMax,max( max(c11,c19),max(c15,c23) ) );
     //Far
//RangeMax -= RangeMax-max(RangeMax,max( max(c25,c37),max(c31,c43) ) );
//       RangeMax -= RangeMax-max(RangeMax,max(max(max(c26,c30),max(c32,c36)),max(max(c38,c42),max(c44,c48))));
//	   RangeMax -= RangeMax-max(RangeMax,max(max(max(c27,c29),max(c33,c35)),max(max(c39,c41),max(c45,c47))));
//RangeMax -= RangeMax-max(RangeMax,max( max(c28,c34),max(c40,c46) ) );




#endif



// -- Blur Mask Kernel --
//////////////////////////
#if BlurMaskKernel == 0 // 5x5 Gradient Kernel - Very Smooth and reflective. Based on an earlier 8(+1) texture fetch approach inspired by LumaSharpen, but which was abandoned as it would have little to no performance benefit when used together with Edge Detection and/or Plain Detection...
int3 BlurTiers[2] = { 1, 2, 3, 4, 6, 9 };			//	[1 , 2 , 3 , 2 , 1]	//	[1/9,2/9,1/3,2/9,1/9]
float4	Mask  = BlurTiers[1][1]*(c01+c03+c05+c07);	//	[2 , 4 , 6 , 4 , 2]	//	[2/9,4/9,2/3,4/9,2/9]
		Mask += BlurTiers[1][0]*(c02+c04+c06+c08);	//	[3 , 6 , 9 , 6 , 3]	//	[1/3,2/3, 1 ,2/3,1/3]
		Mask += BlurTiers[0][2]*(c09+c13+c17+c21);	//	[2 , 4 , 6 , 4 , 2]	//	[2/9,4/9,2/3,4/9,2/9]
		Mask += BlurTiers[0][0]*(c11+c15+c19+c23);	//	[1 , 2 , 3 , 2 , 1]	//	[1/9,2/9,1/3,2/9,1/9]
		Mask += BlurTiers[0][1]*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 0 && MaskSmooth == 1
	Mask  /= 72;
#elif BlurMaskKernel == 0 && MaskSmooth == 0
	Mask += BlurTiers[1][2]*c00;	Mask /= 81;
#endif
//////////////////////////
#if BlurMaskKernel == 1 // 5x5 Fibonacci Kernel - An approcimation of the Golden Ratio, gives excellent balance between smoothness and sharpness.
int3 BlurTiers[2] = { 1, 2, 3, 5, 8, 13 };			//	[1 , 2 , 3 , 2 , 1]
float4	Mask  = BlurTiers[1][1]*(c01+c03+c05+c07);	//	[2 , 5 , 8 , 5 , 2]
		Mask += BlurTiers[1][0]*(c02+c04+c06+c08);	//	[3 , 8 ,13 , 8 , 3]
		Mask += BlurTiers[0][2]*(c09+c13+c17+c21);	//	[2 , 5 , 8 , 5 , 2]
		Mask += BlurTiers[0][0]*(c11+c15+c19+c23);	//	[1 , 2 , 3 , 2 , 1]
		Mask += BlurTiers[0][1]*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 1 && MaskSmooth == 1
	Mask  /= 84;
#elif BlurMaskKernel == 1 && MaskSmooth == 0
	Mask += BlurTiers[1][2]*c00;	Mask /= 97;
#endif

/////////////////
#if BlurMaskKernel == 3 // 5x5 Powers of Phi - An experiment to reduce the instruction count and further increase precision...
												// 	[^1 ,^2 ,^3 ,^2 ,^1]
float4	Mask  = pow(Phi,5)*(c01+c03+c05+c07);	//	[^2 ,^4 ,^5 ,^4 ,^2]
		Mask += pow(Phi,4)*(c02+c04+c06+c08);	//	[^3 ,^5 ,^6 ,^5 ,^3]
		Mask += pow(Phi,3)*(c09+c13+c17+c21);	//	[^2 ,^4 ,^5 ,^4 ,^2]
		Mask += pow(Phi,1)*(c11+c15+c19+c23);	//	[^1 ,^2 ,^3 ,^2 ,^1]
		Mask += pow(Phi,2)*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 3 && MaskSmooth == 1
	Mask /= 116,138;							// ((sqrt(1,25)+0,5)^5*4) + ((sqrt(1,25)+0,5)^4*4) + ((sqrt(1,25)+0,5)^3*4) + ((sqrt(1,25)+0,5)^1*4) + ((sqrt(1,25)+0,5)^2*8)
#elif BlurMaskKernel == 3 && MaskSmooth == 0
	Mask += pow(Phi,6)*c00;	Mask  /= 134,082; 	// ((sqrt(1,25)+0,5)^5*4) + ((sqrt(1,25)+0,5)^4*4) + ((sqrt(1,25)+0,5)^3*4) + ((sqrt(1,25)+0,5)^1*4) + ((sqrt(1,25)+0,5)^2*8) + ((sqrt(1,25)+0,5)^6*1)
#endif



//////////////////////////
#if BlurMaskKernel == 4 // 5x5 Powers of phi - An experiment to reduce the instruction count and further increase precision...
												// 	[^6 ,^5 ,^4 ,^5 ,^6]
float4	Mask  = pow(phi,2)*(c01+c03+c05+c07);	//	[^5 ,^3 ,^2 ,^3 ,^5]
		Mask += pow(phi,3)*(c02+c04+c06+c08);	//	[^4 ,^2  ,1 ,^2 ,^4]
		Mask += pow(phi,4)*(c09+c13+c17+c21);	//	[^5 ,^3 ,^2 ,^3 ,^5]
		Mask += pow(phi,6)*(c11+c15+c19+c23);	//	[^6 ,^5 ,^4 ,^5 ,^6]
		Mask += pow(phi,5)*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 4 && MaskSmooth == 1
	Mask *= .25;									// ((sqrt(1,25)-0,5)^2*4) + ((sqrt(1,25)-0,5)^3*4) + ((sqrt(1,25)-0,5)^4*4) + ((sqrt(1,25)-0,5)^6*4) + ((sqrt(1,25)-0,5)^5*8)
#elif BlurMaskKernel == 4 && MaskSmooth == 0
	Mask += phi*c00;	Mask /= 4+phi; 		// ((sqrt(1,25)-0,5)^2*4) + ((sqrt(1,25)-0,5)^3*4) + ((sqrt(1,25)-0,5)^4*4) + ((sqrt(1,25)-0,5)^6*4) + ((sqrt(1,25)-0,5)^5*8) + ((sqrt(1,25)-0,5)^1*1)
#endif




#if BlurMaskKernel == 5 // 5x5 Powers of phi - An experiment to reduce the instruction count and further increase precision...

float4x4 cT={tex2D(s0, tex + float2(0,-py*3))	,	tex2D(s0, tex + float2(px*3,0))		,	tex2D(s0, tex + float2(0,py*3))		,	tex2D(s0, tex + float2(-px*3,0))};
												// 	[	,	,	,	,^6	,	,	,	]
												// 	[	,	,	,^5 ,^4 ,^5 ,	,	]
float4	Mask  = pow(phi,2)*(c01+c03+c05+c07);	//	[	,	,^5 ,^3 ,^2 ,^3 ,^5	,	]
		Mask += pow(phi,3)*(c02+c04+c06+c08);	//	[	,^6	,^4 ,^2  ,1 ,^2 ,^4	,^6	]
		Mask += pow(phi,4)*(c09+c13+c17+c21);	//	[	,	,^5 ,^3 ,^2 ,^3 ,^5	,	]
		Mask += pow(phi,6)*(cT[0]+cT[1]+cT[2]+cT[3]);	//	[	,	,	,^5 ,^4 ,^5 ,	,	]
												//	[	,	,	,	,^6	,	,	,	]
		Mask += pow(phi,5)*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 5 && MaskSmooth == 1
	Mask *=  .25;									// ((sqrt(1,25)-0,5)^2*4) + ((sqrt(1,25)-0,5)^3*4) + ((sqrt(1,25)-0,5)^4*4) + ((sqrt(1,25)-0,5)^6*4) + ((sqrt(1,25)-0,5)^5*8)
#elif BlurMaskKernel == 5 && MaskSmooth == 0
	Mask += phi*c00;	Mask /= 4+phi; 		// ((sqrt(1,25)-0,5)^2*4) + ((sqrt(1,25)-0,5)^3*4) + ((sqrt(1,25)-0,5)^4*4) + ((sqrt(1,25)-0,5)^6*4) + ((sqrt(1,25)-0,5)^5*8) + ((sqrt(1,25)-0,5)^1*1)
#endif

///////////////////////////
#if BlurMaskKernel == 16 // Experimental - Increases haloing...
// -- Main Code --
//	[c46,c47,c48,c25,c26,c27,c28] c25 c31 c37 c43
//	[c45,c23,c24,c09,c10,c11,c29] c26 c30 c32 c36 c38 c42 c44 c48
//	[c44,c22,c08,c01,c02,c12,c30] c27 c29 c33 c35 c39 c41 c45 c47
//	[c43,c21,c07,c00,c03,c13,c31] c28 c34 c40 c46
//	[c42,c20,c06,c05,c04,c14,c32]
//	[c41,c19,c18,c17,c16,c15,c33]
//	[c40,c39,c38,c37,c36,c35,c34]
float4 c25 = tex2D(s0, tex + float2(0,-py*3));		float4 c26 = tex2D(s0, tex + float2(px,-py*3));
float4 c27 = tex2D(s0, tex + float2(px*2,-py*3));	float4 c28 = tex2D(s0, tex + float2(px,-py)*3);
float4 c29 = tex2D(s0, tex + float2(px*3,-py*2));	float4 c30 = tex2D(s0, tex + float2(px*3,-py));
float4 c31 = tex2D(s0, tex + float2(px*3,0));		float4 c32 = tex2D(s0, tex + float2(px*3,py));
float4 c33 = tex2D(s0, tex + float2(px*3,py*2));	float4 c34 = tex2D(s0, tex + float2(px,py)*3);
float4 c35 = tex2D(s0, tex + float2(px*2,py*3));	float4 c36 = tex2D(s0, tex + float2(px,py*3));
float4 c37 = tex2D(s0, tex + float2(0,py*3));		float4 c38 = tex2D(s0, tex + float2(-px,py*3));
float4 c39 = tex2D(s0, tex + float2(-px*2,py*3));	float4 c40 = tex2D(s0, tex + float2(-px,py)*3);
float4 c41 = tex2D(s0, tex + float2(-px*3,py*2));	float4 c42 = tex2D(s0, tex + float2(-px*3,py));
float4 c43 = tex2D(s0, tex + float2(-px*3,0));		float4 c44 = tex2D(s0, tex + float2(-px*3,-py));
float4 c45 = tex2D(s0, tex + float2(-px*3,-py*2));	float4 c46 = tex2D(s0, tex + float2(-px,-py)*3);
float4 c47 = tex2D(s0, tex + float2(-px*2,-py*3));	float4 c48 = tex2D(s0, tex + float2(-px,-py*3));
#endif
///////////////////////////
#if BlurMaskKernel == 16 // 5x5 Powers of phi - An experiment to reduce the instruction count and further increase precision...
float4	Mask  = pow(phi,2)*(c01+c03+c05+c07);		// 	[^9 ,^8 ,^7 ,^6 ,^7 ,^8 ,^9]
		Mask += pow(phi,3)*(c02+c04+c06+c08);		//	[^8 ,^6 ,^5 ,^4 ,^5 ,^6 ,^8]
		Mask += pow(phi,4)*(c09+c13+c17+c21);		//	[^7 ,^5  ,3 ,^2 ,^3 ,^5 ,^7]
		Mask += pow(phi,6)*(c11+c15+c19+c23);		//	[^6 ,^4 ,^2 ,^1 ,^2 ,^4 ,^6]
													//	[^7 ,^5 ,^3 ,^2 ,^3 ,^5 ,^7]
													//	[^8 ,^6 ,^5 ,^4 ,^5 ,^6 ,^8]
		Mask -= pow(phi,9)*(c28+c34+c40+c46);		//	[^9 ,^8 ,^7 ,^6 ,^7 ,^8 ,^9]
		Mask += pow(phi,5)*(c10+c12+c14+c16+c18+c20+c22+c24);
		Mask -= pow(phi,6)*(c25+c31+c37+c43);
		Mask -= pow(phi,7)*(c26+c30+c32+c36+c38+c42+c44+c48);
		Mask -= pow(phi,8)*(c27+c29+c33+c35+c39+c41+c45+c47);
#endif
#if BlurMaskKernel == 16 && MaskSmooth == 1
	Mask /=  3.2786404500042060718165266253745;								// ((sqrt(1,25)-0,5)^2*4) + ((sqrt(1,25)-0,5)^3*4) + ((sqrt(1,25)-0,5)^4*4) + ((sqrt(1,25)-0,5)^6*4) + ((sqrt(1,25)-0,5)^5*8) + ((sqrt(1,25)-0,5)^6*8) + ((sqrt(1,25)-0,5)^7*8) + ((sqrt(1,25)-0,5)^8*8) + ((sqrt(1,25)-0,5)^9*4)
#elif BlurMaskKernel == 16 && MaskSmooth == 0								// ((sqrt(1,25)-0,5)^2*4) + ((sqrt(1,25)-0,5)^3*4) + ((sqrt(1,25)-0,5)^4*4) + ((sqrt(1,25)-0,5)^5*8) - ((sqrt(1,25)-0,5)^7*8) - ((sqrt(1,25)-0,5)^8*8) - ((sqrt(1,25)-0,5)^9*4)
	Mask += phi*c00;	Mask /= 3.8966744387541009200211134597401; 			// ((sqrt(1,25)-0,5)^2*4) + ((sqrt(1,25)-0,5)^3*4) + ((sqrt(1,25)-0,5)^4*4) + ((sqrt(1,25)-0,5)^6*4) + ((sqrt(1,25)-0,5)^5*8) + ((sqrt(1,25)-0,5)^6*8) + ((sqrt(1,25)-0,5)^7*8) + ((sqrt(1,25)-0,5)^8*8) + ((sqrt(1,25)-0,5)^9*4) + ((sqrt(1,25)-0,5)^1*1)
#endif																		// ((sqrt(1,25)-0,5)^2*4) + ((sqrt(1,25)-0,5)^3*4) + ((sqrt(1,25)-0,5)^4*4) + ((sqrt(1,25)-0,5)^5*8) - ((sqrt(1,25)-0,5)^7*8) - ((sqrt(1,25)-0,5)^8*8) - ((sqrt(1,25)-0,5)^9*4) + ((sqrt(1,25)-0,5)^1*1)

// -- Edge Detection Operator --
/////////////////////////
#if EdgeDetector == 1 // Low-Precision Fibonacci-Operators // Experimental ( 1.6~~:1 ) approcimation of Phi; 
// [ -4,-13,-4 ]	[  4,  0, -4 ]	[  0,  4, 13 ]	[-13, -4,  0 ]
// [  0,  0, 0 ]	[ 13,  0,-13 ]	[ -4,  0,  4 ]	[ -4,  0,  4 ]
// [  4, 13, 4 ]	[  4,  0, -4 ]	[-13, -4,  0 ]	[  0,  4, 13 ]
// Semi-Diagonals // Meant to reduce amplification of aliasing and interlacing artefacts over regular operators, slightly softer results on average.
// [ -5,-13,-21 ]	[ 21,  8, -5 ]	[ -5,  8, 21 ]	[-21,-13, -5 ]
// [  8,  0, -8 ]	[ 13,  0,-13 ]	[-13,  0, 13 ]	[ -8,  0,  8 ]
// [ 21, 13,  5 ]	[  5, -8,-21 ]	[-21, -8,  5 ]	[  5, 13, 21 ]
float4 EdgeTierData = { 4, 13, 0.21, 0.34 };
float2x4 EdgeTierData = { 21, 13, 8, 5,
						4, 0, 0.21,	0.47 };
//[0][0], [0][1], [0][2], [0][3]
//[1][0], [1][1], [1][2], [1][3]
#endif
#if EdgeDetectionOperators == 0
float4x4 Edges1={(abs(abs(c05)-abs(c01))*EdgeTierData[1]
+(abs(c04)-abs(c08)+abs(c06)-abs(c02))*EdgeTierData[0])/EdgeTierData[2] ,
				 (abs(abs(c07)-abs(c03))*EdgeTierData[1]+(abs(c06)-abs(c02)+abs(c08)-abs(c04))*EdgeTierData[0])/EdgeTierData[2] ,
				 (abs(abs(c02)-abs(c06))*EdgeTierData[1]+(abs(c01)-abs(c05)+abs(c03)-abs(c07))*EdgeTierData[0])/EdgeTierData[2] ,
				 (abs(abs(c04)-abs(c08))*EdgeTierData[1]+(abs(c03)-abs(c07)+abs(c05)-abs(c01))*EdgeTierData[0])/EdgeTierData[2]};

float4x4 Edges2={(abs(abs(c05)-abs(c01)+abs(c06)-abs(c02))*EdgeTierData[1]+abs(abs(c04)-abs(c08)+abs(c07)-abs(c03))*EdgeTierData[0])/EdgeTierData[3] ,
				 (abs(abs(c07)-abs(c03)+abs(c08)-abs(c04))*EdgeTierData[1]+abs(abs(c06)-abs(c02)+abs(c01)-abs(c05))*EdgeTierData[0])/EdgeTierData[3] ,
				 (abs(abs(c02)-abs(c06)+abs(c03)-abs(c07))*EdgeTierData[1]+abs(abs(c01)-abs(c05)+abs(c04)-abs(c08))*EdgeTierData[0])/EdgeTierData[3] ,
				 (abs(abs(c04)-abs(c08)+abs(c05)-abs(c01))*EdgeTierData[1]+abs(abs(c03)-abs(c07)+abs(c06)-abs(c02))*EdgeTierData[0])/EdgeTierData[3]};
#endif

/////////////////////////

/////////////////////////
#if EdgeDetector == 2 // Scharr-Operators -  Excellent for Anime, CGI & Live content alike.
// [ -3,-10,-3 ]	[  3,  0, -3 ]	[  0,  3, 10 ]	[-10, -3,  0 ]
// [  0,  0, 0 ]	[ 10,  0,-10 ]	[ -3,  0,  3 ]	[ -3,  0,  3 ]
// [  3, 10, 3 ]	[  3,  0, -3 ]	[-10, -3,  0 ]	[  0,  3, 10 ]
// Semi-Diagonals // Meant to reduce amplification of aliasing and interlacing artefacts over regular operators, slightly softer results on average.
// [ -3,-10,-10 ]	[ 10,  3, -3 ]	[ -3,  3, 10]	[-10,-10, -3 ]
// [  3,  0, -3 ]	[ 10,  0,-10 ]	[-10,  0, 10 ]	[ -3,  0,  3 ]
// [ 10, 10,  3 ]	[  3, -3,-10 ]	[-10, -3,  3 ]	[  3, 10, 10 ]
float4 EdgeTierData = { 3, 10, 0.16, 0.26 };
#endif
/////////////////////////
#if EdgeDetector == 21 // Low-Precision Fibonacci-Operators -   After i realized that 10:(3*2) of Scharr is pretty close to the golden ratio, i started trying out other approximations of it, these give very pleasing results.
// Experimental ( 1.625:1 ) approcimation of Phi; where the smaller value is divided across two pixels.
// [ -4,-13,-4 ]	[  4,  0, -4 ]	[  0,  4, 13 ]	[-13, -4,  0 ]
// [  0,  0, 0 ]	[ 13,  0,-13 ]	[ -4,  0,  4 ]	[ -4,  0,  4 ]
// [  4, 13, 4 ]	[  4,  0, -4 ]	[-13, -4,  0 ]	[  0,  4, 13 ]
// Semi-Diagonals // Meant to reduce amplification of aliasing and interlacing artefacts over regular operators, slightly softer results on average.
// [ -4,-13,-13 ]	[ 13,  4, -4 ]	[ -4,  4, 13 ]	[-13,-13, -4 ]
// [  4,  0, -4 ]	[ 13,  0,-13 ]	[-13,  0, 13 ]	[ -4,  0,  4 ]
// [ 13, 13,  4 ]	[  4, -4,-13 ]	[-13, -4,  4 ]	[  4, 13, 13 ]
float4 EdgeTierData = { 4, 13, 0.21, 0.34 };
#endif
/////////////////////////
#if EdgeDetector == 22 // Medium-Precision GoldenRatio-Operators -   
// Experimental ( 1.61805[...]:1 ) approcimation of Phi; where the smaller value is divided across two pixels.
// [ -72,-233, -72 ]	[  72,  0, -72 ]	[   0, 72, 233 ]	[-233, -72,   0 ]
// [   0,   0,   0 ]	[ 233,  0,-233 ]	[ -72,  0,  72 ]	[ -72,   0,  72 ]
// [  72, 233,  72 ]	[  72,  0, -72 ]	[-233,-72,   0 ]	[   0,  72, 233 ]
// Semi-Diagonals // Meant to reduce amplification of aliasing and interlacing artefacts over regular operators, slightly softer results on average.
// [ -72,-233,-233 ]	[ 233, 72, -72 ]	[ -72, 72, 233 ]	[-233,-233, -72 ]
// [  72,   0, -72 ]	[ 233,  0,-233 ]	[-233,  0, 233 ]	[ -72,   0,  72 ]
// [ 233, 233,  72 ]	[  72,-72,-233 ]	[-233,-72,  72 ]	[  72, 233, 233 ]
float4 EdgeTierData = { 72, 233, 3.77, 6.10 };
#endif
/////////////////////////
#if EdgeDetector == 222 // Medium-Precision GoldenRatio-Operators -   
// Experimental ( 1.61805[...]:1 ) approcimation of Phi; where both values are divided across two pixels.
float4 EdgeTierData = { 72, 116.5, 2.605, 3.77 };
#endif
//////////////////////////
#if EdgeDetector == 223 // Medium-Precision GoldenRatio-Operators -   
// Experimental ( 1.61805[...]:1 ) approcimation of Phi; where both values are divided across two pixels.
float4 EdgeTierData = { 144, 233, 5.21, 7.54 };
#endif
/////////////////////////
#if EdgeDetector == 224 // Medium-Precision GoldenRatio-Operators -   
// Experimental ( 1.61805[...]:1 ) approcimation of Phi; hybrid combo with different behavior for regular and semi-diagonal operators.
float4 EdgeTierData = { 72, 233, 3.77, 5.21 };
#endif
// Special exception for Experimentation purposes. Will eventually get either moved or deleted depending on the results.
#if SemiDiagonalOperators == 1  && EdgeDetector == 24
EdgeTierData[0] *= 2;
#endif
/////////////////////////
#if EdgeDetector == 25 // Experimental; Phi, cut off before zeros and rounded up at convenient clusters of high digits;
// even more precision should be achievable just by adding more digits, but at some point the performance trade-off just isn't worth it; not quite sure how to test that, so i'll just leave this here as an option for anyone who likes to experiment and run benchmarks.
#define prePhi 1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374
float4 EdgeTierData = { .5, prePhi, (1+prePhi/100), (1+prePhi*2/100) };
// Phi rounded, up to 101 digits after the decimal point:
//1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375
#endif

#if EdgeDetector == 26 // Should automatically calculate Phi to maximum available precision while loading shader.
float4 EdgeTierData = { .5, Phi, (1+Phi/100), (1+Phi*2/100) }; // Latter values are for calibrating Sharpening-strength normalization across EdgeDetector modes.
#endif

////////////////////////
// -- Do The Maths -- //
// Idea, halo suppression:
//if dot DetectEdges.r+DetectEdges.b+DetectEdges.g > ;

#if EdgeDetectionOperators == 11 || EdgeDetectionOperators == 33
float4x4 Edges1={abs((c05-c01)*EdgeTierData[1]+(c04-c08+c06-c02)*EdgeTierData[0])/EdgeTierData[2] ,
				 abs((c07-c03)*EdgeTierData[1]+(c06-c02+c08-c04)*EdgeTierData[0])/EdgeTierData[2] ,
				 abs((c02-c06)*EdgeTierData[1]+(c01-c05+c03-c07)*EdgeTierData[0])/EdgeTierData[2] ,
				 abs((c04-c08)*EdgeTierData[1]+(c03-c07+c05-c01)*EdgeTierData[0])/EdgeTierData[2]};
#endif
#if EdgeDetectionOperators == 22 || EdgeDetectionOperators == 33
float4x4 Edges2={abs((c05-c01+c06-c02)*EdgeTierData[1]+(c04-c08+c07-c03)*EdgeTierData[0])/EdgeTierData[3] ,
				 abs((c07-c03+c08-c04)*EdgeTierData[1]+(c06-c02+c01-c05)*EdgeTierData[0])/EdgeTierData[3] ,
				 abs((c02-c06+c03-c07)*EdgeTierData[1]+(c01-c05+c04-c08)*EdgeTierData[0])/EdgeTierData[3] ,
				 abs((c04-c08+c05-c01)*EdgeTierData[1]+(c03-c07+c06-c02)*EdgeTierData[0])/EdgeTierData[3]};
#endif
#if EdgeDetectionOperators == 44 || EdgeDetectionOperators == 66
float4x4 Edges1={(abs(c05-c01)*EdgeTierData[1]+(c04-c08+c06-c02)*EdgeTierData[0])/EdgeTierData[2] ,
				 (abs(c07-c03)*EdgeTierData[1]+(c06-c02+c08-c04)*EdgeTierData[0])/EdgeTierData[2] ,
				 (abs(c02-c06)*EdgeTierData[1]+(c01-c05+c03-c07)*EdgeTierData[0])/EdgeTierData[2] ,
				 (abs(c04-c08)*EdgeTierData[1]+(c03-c07+c05-c01)*EdgeTierData[0])/EdgeTierData[2]};
#endif
#if EdgeDetectionOperators == 55 || EdgeDetectionOperators == 66
float4x4 Edges2={(abs(c05-c01+c06-c02)*EdgeTierData[1]+abs(c04-c08+c07-c03)*EdgeTierData[0])/EdgeTierData[3] ,
				 (abs(c07-c03+c08-c04)*EdgeTierData[1]+abs(c06-c02+c01-c05)*EdgeTierData[0])/EdgeTierData[3] ,
				 (abs(c02-c06+c03-c07)*EdgeTierData[1]+abs(c01-c05+c04-c08)*EdgeTierData[0])/EdgeTierData[3] ,
				 (abs(c04-c08+c05-c01)*EdgeTierData[1]+abs(c03-c07+c06-c02)*EdgeTierData[0])/EdgeTierData[3]};
#endif
#if EdgeDetectionOperators == 77 || EdgeDetectionOperators == 99
float4x4 Edges1={(abs(abs(c05)-abs(c01))*EdgeTierData[1]+(abs(c04)-abs(c08)+abs(c06)-abs(c02))*EdgeTierData[0])/EdgeTierData[2] ,
				 (abs(abs(c07)-abs(c03))*EdgeTierData[1]+(abs(c06)-abs(c02)+abs(c08)-abs(c04))*EdgeTierData[0])/EdgeTierData[2] ,
				 (abs(abs(c02)-abs(c06))*EdgeTierData[1]+(abs(c01)-abs(c05)+abs(c03)-abs(c07))*EdgeTierData[0])/EdgeTierData[2] ,
				 (abs(abs(c04)-abs(c08))*EdgeTierData[1]+(abs(c03)-abs(c07)+abs(c05)-abs(c01))*EdgeTierData[0])/EdgeTierData[2]};
#endif
#if EdgeDetectionOperators == 88 || EdgeDetectionOperators == 99
float4x4 Edges2={(abs(abs(c05)-abs(c01)+abs(c06)-abs(c02))*EdgeTierData[1]+abs(abs(c04)-abs(c08)+abs(c07)-abs(c03))*EdgeTierData[0])/EdgeTierData[3] ,
				 (abs(abs(c07)-abs(c03)+abs(c08)-abs(c04))*EdgeTierData[1]+abs(abs(c06)-abs(c02)+abs(c01)-abs(c05))*EdgeTierData[0])/EdgeTierData[3] ,
				 (abs(abs(c02)-abs(c06)+abs(c03)-abs(c07))*EdgeTierData[1]+abs(abs(c01)-abs(c05)+abs(c04)-abs(c08))*EdgeTierData[0])/EdgeTierData[3] ,
				 (abs(abs(c04)-abs(c08)+abs(c05)-abs(c01))*EdgeTierData[1]+abs(abs(c03)-abs(c07)+abs(c06)-abs(c02))*EdgeTierData[0])/EdgeTierData[3]};
#endif

// -- Anti-Flicker Filter --
#if AntiFlicker == 1 // 
// [ -2,-1,-2 ]
// [ -1, 8,-1 ]
// [ -2,-1,-2 ]
float3 AntiFlickerData = { 4, phi^2, phi };
abs( c00 - ((c01+c03+c05+c07)*AntiFlickerData[1]+(c02+c04+c06+c08)*AntiFlickerData[2])/AntiFlickerData[0] )

#endif

#if EdgeDetectionOperators == 1 || EdgeDetectionOperators == 3
float4x4 Edges1={abs((c05*EdgeTierData[1]+(c04+c06)*EdgeTierData[0])-(c01*EdgeTierData[1]+(c08+c02)*EdgeTierData[0]))/EdgeTierData[2] ,
				 abs((c07*EdgeTierData[1]+(c06+c08)*EdgeTierData[0])-(c03*EdgeTierData[1]+(c02+c04)*EdgeTierData[0]))/EdgeTierData[2] ,
				 abs((c02*EdgeTierData[1]+(c01+c03)*EdgeTierData[0])-(c06*EdgeTierData[1]+(c05+c07)*EdgeTierData[0]))/EdgeTierData[2] ,
				 abs((c04*EdgeTierData[1]+(c03+c05)*EdgeTierData[0])-(c08*EdgeTierData[1]+(c07+c01)*EdgeTierData[0]))/EdgeTierData[2]};
#endif
#if EdgeDetectionOperators == 2 || EdgeDetectionOperators == 3
float4x4 Edges2={abs(((c05+c06)*EdgeTierData[1]+(c04+c07)*EdgeTierData[0])-((c01+c02)*EdgeTierData[1]+(c08+c03)*EdgeTierData[0]))/EdgeTierData[3] ,
				 abs(((c07+c08)*EdgeTierData[1]+(c06+c01)*EdgeTierData[0])-((c03+c04)*EdgeTierData[1]+(c02+c05)*EdgeTierData[0]))/EdgeTierData[3] ,
				 abs(((c02+c03)*EdgeTierData[1]+(c01+c04)*EdgeTierData[0])-((c06+c07)*EdgeTierData[1]+(c05+c08)*EdgeTierData[0]))/EdgeTierData[3] ,
				 abs(((c04+c05)*EdgeTierData[1]+(c03+c06)*EdgeTierData[0])-((c08+c01)*EdgeTierData[1]+(c07+c02)*EdgeTierData[0]))/EdgeTierData[3]};
#endif
#if EdgeDetectionOperators == 4 || EdgeDetectionOperators == 6
float4x4 Edges1={abs(abs(c05*EdgeTierData[1]+(c04+c06)*EdgeTierData[0])-abs(c01*EdgeTierData[1]+(c08+c02)*EdgeTierData[0]))/EdgeTierData[2] ,
				 abs(abs(c07*EdgeTierData[1]+(c06+c08)*EdgeTierData[0])-abs(c03*EdgeTierData[1]+(c02+c04)*EdgeTierData[0]))/EdgeTierData[2] ,
				 abs(abs(c02*EdgeTierData[1]+(c01+c03)*EdgeTierData[0])-abs(c06*EdgeTierData[1]+(c05+c07)*EdgeTierData[0]))/EdgeTierData[2] ,
				 abs(abs(c04*EdgeTierData[1]+(c03+c05)*EdgeTierData[0])-abs(c08*EdgeTierData[1]+(c07+c01)*EdgeTierData[0]))/EdgeTierData[2]};
#endif
#if EdgeDetectionOperators == 5 || EdgeDetectionOperators == 6
float4x4 Edges2={abs(abs((c05+c06)*EdgeTierData[1]+(c04+c07)*EdgeTierData[0])-abs((c01+c02)*EdgeTierData[1]+(c08+c03)*EdgeTierData[0]))/EdgeTierData[3] ,
				 abs(abs((c07+c08)*EdgeTierData[1]+(c06+c01)*EdgeTierData[0])-abs((c03+c04)*EdgeTierData[1]+(c02+c05)*EdgeTierData[0]))/EdgeTierData[3] ,
				 abs(abs((c02+c03)*EdgeTierData[1]+(c01+c04)*EdgeTierData[0])-abs((c06+c07)*EdgeTierData[1]+(c05+c08)*EdgeTierData[0]))/EdgeTierData[3] ,
				 abs(abs((c04+c05)*EdgeTierData[1]+(c03+c06)*EdgeTierData[0])-abs((c08+c01)*EdgeTierData[1]+(c07+c02)*EdgeTierData[0]))/EdgeTierData[3]};
#endif
#if EdgeDetectionOperators == 7 || EdgeDetectionOperators == 9
float4x4 Edges1={abs(abs(c05)*EdgeTierData[1]+(abs(c04)+abs(c06))*EdgeTierData[0])-(abs(c01)*EdgeTierData[1]+(abs(c08)+abs(c02)*EdgeTierData[0]))/EdgeTierData[2] ,
				 abs(abs(c07)*EdgeTierData[1]+(abs(c06)+abs(c08))*EdgeTierData[0])-(abs(c03)*EdgeTierData[1]+(abs(c02)+abs(c04)*EdgeTierData[0]))/EdgeTierData[2] ,
				 abs(abs(c02)*EdgeTierData[1]+(abs(c01)+abs(c03))*EdgeTierData[0])-(abs(c06)*EdgeTierData[1]+(abs(c05)+abs(c07)*EdgeTierData[0]))/EdgeTierData[2] ,
				 abs(abs(c04)*EdgeTierData[1]+(abs(c03)+abs(c05))*EdgeTierData[0])-(abs(c08)*EdgeTierData[1]+(abs(c07)+abs(c01)*EdgeTierData[0]))/EdgeTierData[2]};
#endif
#if EdgeDetectionOperators == 8 || EdgeDetectionOperators == 9
float4x4 Edges2={abs((abs(c05)+abs(c06))*EdgeTierData[1]+(abs(c04)+abs(c07))*EdgeTierData[0])-((abs(c01)+abs(c02))*EdgeTierData[1]+(abs(c08)+abs(c03)*EdgeTierData[0]))/EdgeTierData[3] ,
				 abs((abs(c07)+abs(c08))*EdgeTierData[1]+(abs(c06)+abs(c01))*EdgeTierData[0])-((abs(c03)+abs(c04))*EdgeTierData[1]+(abs(c02)+abs(c05)*EdgeTierData[0]))/EdgeTierData[3] ,
				 abs((abs(c02)+abs(c03))*EdgeTierData[1]+(abs(c01)+abs(c04))*EdgeTierData[0])-((abs(c06)+abs(c07))*EdgeTierData[1]+(abs(c05)+abs(c08)*EdgeTierData[0]))/EdgeTierData[3] ,
				 abs((abs(c04)+abs(c05))*EdgeTierData[1]+(abs(c03)+abs(c06))*EdgeTierData[0])-((abs(c08)+abs(c01))*EdgeTierData[1]+(abs(c07)+abs(c02)*EdgeTierData[0]))/EdgeTierData[3]};
#endif

// My Best experimental approach this far:
#if		EdgeMathMode == 0 && EdgeDetectionOperators == 0
float4  DetectEdges ={1,1,1,1};
#elif	EdgeMathMode == 0 && EdgeDetectionOperators == 1 || EdgeMathMode == 0 && EdgeDetectionOperators == 4 || EdgeMathMode == 0 && EdgeDetectionOperators == 7
float4  DetectEdges ={saturate(		max(max( Edges1[0],Edges1[1] ) , max( Edges1[2],Edges1[3] ) ))};
#elif	EdgeMathMode == 0 && EdgeDetectionOperators == 2 || EdgeMathMode == 0 && EdgeDetectionOperators == 5 || EdgeMathMode == 0 && EdgeDetectionOperators == 8
float4  DetectEdges ={saturate(		max(max( Edges2[0],Edges2[1] ) , max( Edges2[2],Edges2[3] ) ))};
#elif	EdgeMathMode == 0 && EdgeDetectionOperators == 3 || EdgeMathMode == 0 && EdgeDetectionOperators == 6 || EdgeMathMode == 0 && EdgeDetectionOperators == 9
float4  DetectEdges ={saturate( max(max(max( Edges1[0],Edges1[1] ) , max( Edges1[2],Edges1[3] )),max(max( Edges2[0],Edges2[1] ) , max( Edges2[2],Edges2[3] )) ))};




//old stuff that needs to be rewritten:
#elif EdgeMathMode == 1	// Kirsch-like max approach:

float	DetectEdges = max(max(Edge1,Edge2),max(Edge3,Edge4));
float	DetectEdges = max(max(Edge5,Edge6),max(Edge7,Edge8));


#elif EdgeMathMode == 2	// placeholder for theoretically sound approaches:
float	DetectEdges = saturate(sqrt(dot( dot( abs(Edge1),abs(Edge2) ),dot( abs(Edge3),abs(Edge4) ) )));// with or without abs?

#elif EdgeMathMode == 3	// Recommended approach:
float	DetectEdges = saturate(dot( dot( abs(Edge1),abs(Edge2) ),dot( abs(Edge3),abs(Edge4) ) )/4);

#elif EdgeMathMode == 4	// SharpenComplex aproach:
float	DetectEdges = saturate(sqrt(mul(Edge1,Edge1)+mul(Edge2,Edge2)+mul(Edge3,Edge3)+mul(Edge4,Edge4)));

#elif EdgeMathMode == 5	// Min aproach:
float	DetectEdges = saturate(min(min(abs(Edge1),abs(Edge2)),min(abs(Edge3),abs(Edge4))));

#else 					// Experimental/Diagnostic aproaches:
//float	DetectEdges = saturate(dot(dot(abs(Edge1),abs(Edge2)),dot(abs(Edge3),abs(Edge4))));
//float	DetectEdges = saturate((abs(Edge1)+abs(Edge2)+abs(Edge3)+abs(Edge4))/4);
//float	DetectEdges = sqrt(Edge1+Edge2+Edge3+Edge4/4);
//float	DetectEdges = abs(Edge1+Edge2+Edge3+Edge4)/4;
//float	DetectEdges = sqrt(dot(Edge1,Edge2)+dot(Edge3,Edge4))/4;
//float	DetectEdges = abs(dot(Edge1,Edge2)+dot(Edge3,Edge4))/4;
//float	DetectEdges = saturate((Edge1+Edge2+Edge3+Edge4)/4);
//float	DetectEdges = abs(dot(abs(Edge1),abs(Edge2))+dot(abs(Edge3),abs(Edge4)))/4;
float	DetectEdges = dot(dot( abs(Edge1),abs(Edge2) ),dot( abs(Edge3),abs(Edge4) ))/4;
//float	DetectEdges = saturate(sqrt(dot( dot(Edge1,Edge2),dot(Edge3,Edge4) ))/4);
//float	DetectEdges = saturate(sqrt( mul(Edge1,Edge2)+mul(Edge3,Edge4) ));
#endif


//EdgeStrength Color Min - Too Soft
	//float	EdgeStrength = min(min(DetectEdges.r,DetectEdges.b),DetectEdges.g);
//EdgeStrength Color Average - Softer
	//float	EdgeStrength = (DetectEdges.r+DetectEdges.b+DetectEdges.g)/3;
//EdgeStrength Color Max - Darker lines and weaker haloes due to better line adherence.
	float	EdgeStrength = max(max(DetectEdges.r,DetectEdges.b),DetectEdges.g);
//EdgeStrength Color Sum - Too Blurry
	//float	EdgeStrength = (DetectEdges.r+DetectEdges.b+DetectEdges.g);

float4 EdgeSharpeningMath;
#if DynamicSharpening == 2 && ReciprocalDynamicS == 0 || DynamicSharpening == 3 && ReciprocalDynamicS == 0 || DynamicSharpening == 2 && ReciprocalDynamicS == 1 || DynamicSharpening == 3 && ReciprocalDynamicS == 1
EdgeSharpeningMath = c00-(Mask-c00)*EdgeStrength*EdgeSharpenFactor;
#elif DynamicSharpening == 2 && ReciprocalDynamicS == 2 || DynamicSharpening == 3 && ReciprocalDynamicS == 2 || DynamicSharpening == 2 && ReciprocalDynamicS == 3 || DynamicSharpening == 3 && ReciprocalDynamicS == 3
EdgeSharpeningMath = c00-(Mask-c00)*(1/EdgeStrength)*EdgeSharpenFactor;
#else
EdgeSharpeningMath = c00-(Mask-c00)*EdgeSharpenFactor;
#endif

float4 TextureSharpeningMath;
#if DynamicSharpening == 1 && ReciprocalDynamicS == 0 || DynamicSharpening == 3 && ReciprocalDynamicS == 0 || DynamicSharpening == 1 && ReciprocalDynamicS == 2 || DynamicSharpening == 3 && ReciprocalDynamicS == 2
TextureSharpeningMath = c00-(Mask-c00)*EdgeStrength*TextureSharpenFactor;
#elif DynamicSharpening == 1 && ReciprocalDynamicS == 1 || DynamicSharpening == 3 && ReciprocalDynamicS == 1 || DynamicSharpening == 1 && ReciprocalDynamicS == 3 || DynamicSharpening == 3 && ReciprocalDynamicS == 3
TextureSharpeningMath = c00-(Mask-c00)*(1/EdgeStrength)*TextureSharpenFactor;
#else
TextureSharpeningMath = c00-(Mask-c00)*TextureSharpenFactor;
#endif

#if AntiHaloMode == 1 || AntiHaloMode == 3
float4 FinalTexture=clamp(TextureSharpeningMath, RangeMin, RangeMax);
#else
float4 FinalTexture=TextureSharpeningMath;
#endif
#if AntiHaloMode == 2 || AntiHaloMode == 3
float4 FinalEdge=clamp(EdgeSharpeningMath, RangeMin, RangeMax);
#else
float4 FinalEdge=EdgeSharpeningMath;
#endif


	 if (EdgeStrength>HighThreshold)
		{EdgeSharpeningMath.a = 1; return FinalEdge;}
else if (EdgeStrength>LowThreshold)
		{TextureSharpeningMath.a = 1; return FinalTexture;}
	 else{c00.a = 1; return c00;}

}