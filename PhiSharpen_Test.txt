// Phi Sharpen Pre-Alpha-Test=ps_3_0
// Code by Nuihc88

#ifndef s0
	sampler s0 :	register(s0);
	float4 p0 :		register(c0);
	#define width	(p0[0])
	#define height	(p0[1])
	#define px		(1./p0[0])
	#define py		(1./p0[1])
#endif

// -- Settings --

#define TextureSharpenFactor 3.2		// Optimal range: ?
#define EdgeSharpenFactor 2.4			// Optimal range: ?
#define HighThreshold 0.667				// Optimal range: ?
#define LowThreshold 0.333				// Optimal range: ?
#define EdgeDetection 0
#define BlurMaskKernel 0

// -- Main Code --
//	[c23,c24,c09,c10,c11]
//	[c22,c08,c01,c02,c12]
//	[c21,c07,c00,c03,c13]
//	[c20,c06,c05,c04,c14]
//	[c19,c18,c17,c16,c15]
float4 main( float2 tex : TEXCOORD0 ) : COLOR {	float4 c00 = tex2D(s0, tex);
float4 c01 = tex2D(s0, tex + float2(0,-py));	float4 c02 = tex2D(s0, tex + float2(px,-py));
float4 c03 = tex2D(s0, tex + float2(px,0));		float4 c04 = tex2D(s0, tex + float2(px,py));
float4 c05 = tex2D(s0, tex + float2(0,py));		float4 c06 = tex2D(s0, tex + float2(-px,py));
float4 c07 = tex2D(s0, tex + float2(-px,0));	float4 c08 = tex2D(s0, tex + float2(-px,-py));
float4 c09 = tex2D(s0, tex + float2(0,-py*2));	float4 c10 = tex2D(s0, tex + float2( px,-py*2));
float4 c11 = tex2D(s0, tex + float2(px,-py)*2);	float4 c12 = tex2D(s0, tex + float2( px*2,-py));
float4 c13 = tex2D(s0, tex + float2(px*2,0));	float4 c14 = tex2D(s0, tex + float2( px*2,py));
float4 c15 = tex2D(s0, tex + float2(px,py)*2);	float4 c16 = tex2D(s0, tex + float2(-px,py*2));
float4 c17 = tex2D(s0, tex + float2(0,py*2));	float4 c18 = tex2D(s0, tex + float2(-px,py*2));
float4 c19 = tex2D(s0, tex + float2(-px,py)*2);	float4 c20 = tex2D(s0, tex + float2(-px*2,py));
float4 c21 = tex2D(s0, tex + float2(-px*2,0));	float4 c22 = tex2D(s0, tex + float2(-px*2,-py));
float4 c23 = tex2D(s0, tex + float2(-px,-py)*2);float4 c24 = tex2D(s0, tex + float2(-px,-py*2));

//float4 s00 = sin(c00); // c00.a  -= EdgeSine;
//float4 s01 = c01*(dot(1-(abs(c00-c01)),1-(abs(c00-c01)))/256); float4 s02 = c02*(dot(1-(abs(c00-c02)),1-(abs(c00-c01)))/256); float4 s03 = c03*(dot(1-(abs(c00-c03)),1-(abs(c00-c01)))/256);
//float4 s04 = c04*(dot(1-(abs(c00-c04)),1-(abs(c00-c04)))/256); float4 s05 = c05*(dot(1-(abs(c00-c05)),1-(abs(c00-c05)))/256); float4 s06 = c06*(dot(1-(abs(c00-c06)),1-(abs(c00-c06)))/256);
//float4 s07 = c07*(dot(1-(abs(c00-c07)),1-(abs(c00-c07)))/256); float4 s08 = c08*(dot(1-(abs(c00-c08)),1-(abs(c00-c08)))/256); float4 s09 = c09*(dot(1-(abs(c00-c09)),1-(abs(c00-c09)))/256);
//float4 s10 = c10*(dot(1-(abs(c00-c10)),1-(abs(c00-c10)))/256); float4 s11 = c11*(dot(1-(abs(c00-c11)),1-(abs(c00-c11)))/256); float4 s12 = c12*(dot(1-(abs(c00-c12)),1-(abs(c00-c12)))/256);
//float4 s13 = c13*(dot(1-(abs(c00-c13)),1-(abs(c00-c13)))/256); float4 s14 = c14*(dot(1-(abs(c00-c14)),1-(abs(c00-c14)))/256); float4 s15 = c15*(dot(1-(abs(c00-c15)),1-(abs(c00-c15)))/256);
//float4 s16 = c16*(dot(1-(abs(c00-c16)),1-(abs(c00-c16)))/256); float4 s17 = c17*(dot(1-(abs(c00-c17)),1-(abs(c00-c17)))/256); float4 s18 = c18*(dot(1-(abs(c00-c18)),1-(abs(c00-c18)))/256);
//float4 s19 = c19*(dot(1-(abs(c00-c19)),1-(abs(c00-c19)))/256); float4 s20 = c20*(dot(1-(abs(c00-c20)),1-(abs(c00-c20)))/256); float4 s21 = c21*(dot(1-(abs(c00-c21)),1-(abs(c00-c21)))/256);
//float4 s22 = c22*(dot(1-(abs(c00-c22)),1-(abs(c00-c22)))/256); float4 s23 = c23*(dot(1-(abs(c00-c23)),1-(abs(c00-c23)))/256); float4 s24 = c24*(dot(1-(abs(c00-c24)),1-(abs(c00-c24)))/256);

// use inverted dot product from pixel rgb as a multiplier for Pseudo-Plain Detection. 
//float4 s00 = sin(c00); // c00.a  -= EdgeSine;
//float4 s01 = 1-saturate((dot(c00,c01))/256); float4 s02 = 1-saturate((dot(c00,c02))/256); float4 s03 = 1-saturate((dot(c00,c03))/256);
//float4 s04 = 1-saturate((dot(c00,c04))/256); float4 s05 = 1-saturate((dot(c00,c05))/256); float4 s06 = 1-saturate((dot(c00,c06))/256);
//float4 s07 = 1-saturate((dot(c00,c07))/256); float4 s08 = 1-saturate((dot(c00,c08))/256); float4 s09 = 1-saturate((dot(c00,c09))/256);
//float4 s10 = 1-saturate((dot(c00,c10))/256); float4 s11 = 1-saturate((dot(c00,c11))/256); float4 s12 = 1-saturate((dot(c00,c12))/256);
//float4 s13 = 1-saturate((dot(c00,c13))/256); float4 s14 = 1-saturate((dot(c00,c14))/256); float4 s15 = 1-saturate((dot(c00,c15))/256);
//float4 s16 = 1-saturate((dot(c00,c16))/256); float4 s17 = 1-saturate((dot(c00,c17))/256); float4 s18 = 1-saturate((dot(c00,c18))/256);
//float4 s19 = 1-saturate((dot(c00,c19))/256); float4 s20 = 1-saturate((dot(c00,c20))/256); float4 s21 = 1-saturate((dot(c00,c21))/256);
//float4 s22 = 1-saturate((dot(c00,c22))/256); float4 s23 = 1-saturate((dot(c00,c23))/256); float4 s24 = 1-saturate((dot(c00,c24))/256);

// use inverted dot product from pixel rgb, divided by 3, as a multiplier for Pseudo-Plain Detection. 
//float4 s00 = sin(c00); // c00.a  -= EdgeSine; // where to place abs?
//float4 s01 = 1-saturate(abs(dot(c00,c01) )/768); float4 s02 = 1-saturate(abs(dot(c00,c02) )/768); float4 s03 = 1-saturate(abs(dot(c00,c03) )/768);
//float4 s04 = 1-saturate(abs(dot(c00,c04) )/768); float4 s05 = 1-saturate(abs(dot(c00,c05) )/768); float4 s06 = 1-saturate(abs(dot(c00,c06) )/768);
//float4 s07 = 1-saturate(abs(dot(c00,c07) )/768); float4 s08 = 1-saturate(abs(dot(c00,c08) )/768); float4 s09 = 1-saturate(abs(dot(c00,c09) )/768);
//float4 s10 = 1-saturate(abs(dot(c00,c10) )/768); float4 s11 = 1-saturate(abs(dot(c00,c11) )/768); float4 s12 = 1-saturate(abs(dot(c00,c12) )/768);
//float4 s13 = 1-saturate(abs(dot(c00,c13) )/768); float4 s14 = 1-saturate(abs(dot(c00,c14) )/768); float4 s15 = 1-saturate(abs(dot(c00,c15) )/768);
//float4 s16 = 1-saturate(abs(dot(c00,c16) )/768); float4 s17 = 1-saturate(abs(dot(c00,c17) )/768); float4 s18 = 1-saturate(abs(dot(c00,c18) )/768);
//float4 s19 = 1-saturate(abs(dot(c00,c19) )/768); float4 s20 = 1-saturate(abs(dot(c00,c20) )/768); float4 s21 = 1-saturate(abs(dot(c00,c21) )/768);
//float4 s22 = 1-saturate(abs(dot(c00,c22) )/768); float4 s23 = 1-saturate(abs(dot(c00,c23) )/768); float4 s24 = 1-saturate(abs(dot(c00,c24) )/768);

// use inverted dot product from pixel rgb, divided by 3, as a multiplier for Pseudo-Plain Detection. 
//float4 s00 = c00.a; // c00.a  -= EdgeSine; // where to place abs?/Is it needed?
//float4 s01 = 1-saturate((dot(abs(c00),abs(c01)) )/768); float4 s02 = 1-saturate((dot(abs(c00),abs(c02)) )/768); float4 s03 = 1-saturate((dot(abs(c00),abs(c03)) )/768);
//float4 s04 = 1-saturate((dot(abs(c00),abs(c04)) )/768); float4 s05 = 1-saturate((dot(abs(c00),abs(c05)) )/768); float4 s06 = 1-saturate((dot(abs(c00),abs(c06)) )/768);
//float4 s07 = 1-saturate((dot(abs(c00),abs(c07)) )/768); float4 s08 = 1-saturate((dot(abs(c00),abs(c08)) )/768); float4 s09 = 1-saturate((dot(abs(c00),abs(c09)) )/768);
//float4 s10 = 1-saturate((dot(abs(c00),abs(c10)) )/768); float4 s11 = 1-saturate((dot(abs(c00),abs(c11)) )/768); float4 s12 = 1-saturate((dot(abs(c00),abs(c12)) )/768);
//float4 s13 = 1-saturate((dot(abs(c00),abs(c13)) )/768); float4 s14 = 1-saturate((dot(abs(c00),abs(c14)) )/768); float4 s15 = 1-saturate((dot(abs(c00),abs(c15)) )/768);
//float4 s16 = 1-saturate((dot(abs(c00),abs(c16)) )/768); float4 s17 = 1-saturate((dot(abs(c00),abs(c17)) )/768); float4 s18 = 1-saturate((dot(abs(c00),abs(c18)) )/768);
//float4 s19 = 1-saturate((dot(abs(c00),abs(c19)) )/768); float4 s20 = 1-saturate((dot(abs(c00),abs(c20)) )/768); float4 s21 = 1-saturate((dot(abs(c00),abs(c21)) )/768);
//float4 s22 = 1-saturate((dot(abs(c00),abs(c22)) )/768); float4 s23 = 1-saturate((dot(abs(c00),abs(c23)) )/768); float4 s24 = 1-saturate((dot(abs(c00),abs(c24)) )/768);

// use inverted dot product from pixel rgb, divided by 3, as a multiplier for Pseudo-Plain Detection. 
//float Normalizer = 196608; // c00.a  -= EdgeSine; // where to place abs?/Is it needed?
//float4 s01 = 1-saturate( abs(dot(c00,c01) )/Normalizer); float4 s02 = 1-saturate( abs(dot(c00,c02) )/Normalizer); float4 s03 = 1-saturate( abs(dot(c00,c03) )/Normalizer);
//float4 s04 = 1-saturate( abs(dot(c00,c04) )/Normalizer); float4 s05 = 1-saturate( abs(dot(c00,c05) )/Normalizer); float4 s06 = 1-saturate( abs(dot(c00,c06) )/Normalizer);
//float4 s07 = 1-saturate( abs(dot(c00,c07) )/Normalizer); float4 s08 = 1-saturate( abs(dot(c00,c08) )/Normalizer); float4 s09 = 1-saturate( abs(dot(c00,c09) )/Normalizer);
//float4 s10 = 1-saturate( abs(dot(c00,c10) )/Normalizer); float4 s11 = 1-saturate( abs(dot(c00,c11) )/Normalizer); float4 s12 = 1-saturate( abs(dot(c00,c12) )/Normalizer);
//float4 s13 = 1-saturate( abs(dot(c00,c13) )/Normalizer); float4 s14 = 1-saturate( abs(dot(c00,c14) )/Normalizer); float4 s15 = 1-saturate( abs(dot(c00,c15) )/Normalizer);
//float4 s16 = 1-saturate( abs(dot(c00,c16) )/Normalizer); float4 s17 = 1-saturate( abs(dot(c00,c17) )/Normalizer); float4 s18 = 1-saturate( abs(dot(c00,c18) )/Normalizer);
//float4 s19 = 1-saturate( abs(dot(c00,c19) )/Normalizer); float4 s20 = 1-saturate( abs(dot(c00,c20) )/Normalizer); float4 s21 = 1-saturate( abs(dot(c00,c21) )/Normalizer);
//float4 s22 = 1-saturate( abs(dot(c00,c22) )/Normalizer); float4 s23 = 1-saturate( abs(dot(c00,c23) )/Normalizer); float4 s24 = 1-saturate( abs(dot(c00,c24) )/Normalizer);

// Pseudo-Plain Detector 
// Assesses the probability of two pixels being on the same plain and then reduces it's influence with the resulting multiplier.
#if BlurMaskKernel == 5
// use normalized inverted dot product from pixel rgb as a multiplier for Pseudo-Plain Detection. 
float Normalizer = 256; // c00.a  -= EdgeSine; // where to place abs?/Is it needed?
float4 s01 = 1-saturate( abs(dot(c00.rgb,c01.rgb) )*Normalizer); float4 s02 = 1-saturate( abs(dot(c00.rgb,c02.rgb) )*Normalizer); float4 s03 = 1-saturate( abs(dot(c00.rgb,c03.rgb) )*Normalizer);
float4 s04 = 1-saturate( abs(dot(c00.rgb,c04.rgb) )*Normalizer); float4 s05 = 1-saturate( abs(dot(c00.rgb,c05.rgb) )*Normalizer); float4 s06 = 1-saturate( abs(dot(c00.rgb,c06.rgb) )*Normalizer);
float4 s07 = 1-saturate( abs(dot(c00.rgb,c07.rgb) )*Normalizer); float4 s08 = 1-saturate( abs(dot(c00.rgb,c08.rgb) )*Normalizer); float4 s09 = 1-saturate( abs(dot(c00.rgb,c09.rgb) )*Normalizer);
float4 s10 = 1-saturate( abs(dot(c00.rgb,c10.rgb) )*Normalizer); float4 s11 = 1-saturate( abs(dot(c00.rgb,c11.rgb) )*Normalizer); float4 s12 = 1-saturate( abs(dot(c00.rgb,c12.rgb) )*Normalizer);
float4 s13 = 1-saturate( abs(dot(c00.rgb,c13.rgb) )*Normalizer); float4 s14 = 1-saturate( abs(dot(c00.rgb,c14.rgb) )*Normalizer); float4 s15 = 1-saturate( abs(dot(c00.rgb,c15.rgb) )*Normalizer);
float4 s16 = 1-saturate( abs(dot(c00.rgb,c16.rgb) )*Normalizer); float4 s17 = 1-saturate( abs(dot(c00.rgb,c17.rgb) )*Normalizer); float4 s18 = 1-saturate( abs(dot(c00.rgb,c18.rgb) )*Normalizer);
float4 s19 = 1-saturate( abs(dot(c00.rgb,c19.rgb) )*Normalizer); float4 s20 = 1-saturate( abs(dot(c00.rgb,c20.rgb) )*Normalizer); float4 s21 = 1-saturate( abs(dot(c00.rgb,c21.rgb) )*Normalizer);
float4 s22 = 1-saturate( abs(dot(c00.rgb,c22.rgb) )*Normalizer); float4 s23 = 1-saturate( abs(dot(c00.rgb,c23.rgb) )*Normalizer); float4 s24 = 1-saturate( abs(dot(c00.rgb,c24.rgb) )*Normalizer);



//768 / 1,6180339887498948482045868343656 =  474.65010335991924342112268879282
//768 * 1,6180339887498948482045868343656 = 1242.6501033599192434211226887928

//float3 sineC = 1-sin(c01.rgb-c00.rgb);
//float3 sineC = 1-sin(dot(c01.rgb-c00.rgb));
//float3 sineC = 1-dot(sin(c01.rgb-c00.rgb));
//float3 sineC = 1-sin(mul(c01.rgb-c00.rgb));
//float3 sineC = 1-mul(sin(c01.rgb-c00.rgb));

float3 sineDot = dot(s00.rgb,s00.rgb);

float4 ColorInversion = float4(1 - s00.rgb, s00.a);


//float4 PixelComp = s00.rgb-s00.rgb;

  #if Diagnostics == 1
    //inputcolor.rgb = abs(sharp * 4.0);
    inputcolor.rgb = saturate(0.5 + (sharp_luma * 4)).rrr;
  #endif

  return saturate(inputcolor);

}

// -- Blur Mask Kernel --

#if BlurMaskKernel == 0 // 5x5 Gradient Kernel - Very Smooth and reflective. Based on an earlier 8(+1) texture fetch approach inspired by LumaSharpen, which was later abandoned as it would have little to no performance benefit when used together with Edge Detection and/or Plain Detection...
int3 BlurTiers[2] = { 1, 2, 3, 4, 6, 9 }; 			// 	[1 , 2 , 3 , 2 , 1]	//	[1/9,2/9,1/3,2/9,1/9]
float4	Blur  = BlurTiers[1][1]*(c01+c03+c05+c07);	//	[2 , 4 , 6 , 4 , 2]	//	[2/9,4/9,2/3,4/9,2/9]
		Blur += BlurTiers[1][0]*(c02+c04+c06+c08);	//	[3 , 6 , 9 , 6 , 3]	//	[1/3,2/3, 1 ,2/3,1/3]
		Blur += BlurTiers[0][2]*(c09+c13+c17+c21);	//	[2 , 4 , 6 , 4 , 2]	//	[2/9,4/9,2/3,4/9,2/9]
		Blur += BlurTiers[0][0]*(c11+c15+c19+c23);	//	[1 , 2 , 3 , 2 , 1]	//	[1/9,2/9,1/3,2/9,1/9]
		Blur += BlurTiers[0][1]*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 0 && MaskSmooth == 1
	Blur  /= 72;
#elif BlurMaskKernel == 0 && MaskSmooth == 0
	Blur += BlurTiers[1][2]*c00;	Blur  /= 81;
#endif

#if BlurMaskKernel == 1 // 5x5 Fibonacci Kernel - Should give just about perfect balance between smooth and sharp.
int3 BlurTiers[2] = { 1, 2, 3, 5, 8, 13 }; 			// 	[1 , 2 , 3 , 2 , 1]
float4	Blur  = BlurTiers[1][1]*(c01+c03+c05+c07);	//	[2 , 5 , 8 , 5 , 2]
		Blur += BlurTiers[1][0]*(c02+c04+c06+c08);	//	[3 , 8 ,13 , 8 , 3]
		Blur += BlurTiers[0][2]*(c09+c13+c17+c21);	//	[2 , 5 , 8 , 5 , 2]
		Blur += BlurTiers[0][0]*(c11+c15+c19+c23);	//	[1 , 2 , 3 , 2 , 1]
		Blur += BlurTiers[0][1]*(c10+c12+c14+c16+c18+c20+c22+c24);
#endif
#if BlurMaskKernel == 1 && MaskSmooth == 1
	Blur  /= 84;
#elif BlurMaskKernel == 1 && MaskSmooth == 0
	Blur += BlurTiers[1][2]*c00;	Blur  /= 97;
//float4	sBlur  = s01+s02+s03+s04+s05+s06+s07+s08+s09+s10+s11+s12+s13+s14+s15+s16+s17+s18+s19+s20s21+s22+s23+s24;
#endif


// -- Edge Detection Operator --

#if EdgeDetection == 0 // Half-Diagonal Scharr-Operators -  Excellent for Anime, CGI & Live content alike.
// Meant to reduce amplification of aliasing and interlacing artefacts over regular Scharr operators, as well as required number of math-operations for a given result.
// [ -3,-10,-10 ]	[ 10,  3, -3]	[ -3,  3, 10]	[-10,-10, -3]
// [  3,  0, -3 ]	[ 10,  0,-10]	[-10,  0, 10]	[ -3,  0,  3]
// [ 10, 10,  3 ]	[  3, -3,-10]	[-10, -3,  3]	[  3, 10, 10]
float EdgeTier1 = 10; float EdgeTier2 = 3;
float Edge1 = ((c05+c06)*EdgeTier1+(c04+c07)*EdgeTier2)-((c01+c02)*EdgeTier1+(c08+c03)*EdgeTier2);
float Edge2 = ((c07+c08)*EdgeTier1+(c06+c01)*EdgeTier2)-((c03+c04)*EdgeTier1+(c02+c05)*EdgeTier2);
float Edge3 = ((c02+c03)*EdgeTier1+(c01+c04)*EdgeTier2)-((c06+c07)*EdgeTier1+(c05+c08)*EdgeTier2);
float Edge4 = ((c04+c05)*EdgeTier1+(c03+c06)*EdgeTier2)-((c08+c01)*EdgeTier1+(c07+c02)*EdgeTier2);
#endif


float	EdgeMath = saturate((abs(Edge1)+abs(Edge2)+abs(Edge3)+abs(Edge4))/4);
s00.a -= 1-EdgeMath; //swizzle for Canny & Ouruboros Algos, restore to 1 later.
float	EdgeSine = sin(EdgeMath);


// -- DoTheMaths --
if (EdgeMath>=dot(HighThreshold,HighThreshold))
		{return s00*(EdgeSharpenFactor) - Blur*(EdgeSharpenFactor-1);}
if (EdgeMath>=dot(LowThreshold,LowThreshold) && EdgeMath<dot(HighThreshold,HighThreshold))
		{return s00*(TextureSharpenFactor) - Blur*(TextureSharpenFactor-1);}
else	{return s00;}
}